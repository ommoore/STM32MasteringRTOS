Real-Time Computing is equivalent to Predictable computing, not fast computing.
Real-time deals with guarantees, not with raw speed.
Having more Processors, more RAM, faster bus interfaces doesnt make a system real-time!!
A Real Time System deals with guarantees, not with promises.

A Real time system is one in which the correctness of the computations not only depends upon the logical correctness of the computation, but also
upon the time at which the result is produced. If the timing constraints are not met, system failure is said to have occurred.

Real Time Applications (RTAs)
- They are not fast executing applications.
- They are time deterministic applications, meaning their response time to events is almost constant.
- There could be a small deviation in RTAs response time, in terms of ms or seconds which will fall into the category of "soft real time applications".
- Hard real time functions must complete within a given time limit; failure to do so will result in absolute failure of the system.

"Hard Real Time application" - Crash detection + Air bag deployment
"Soft Real Time application" - Keyboard key-presses where delay is tolerable

More examples of RTAs: Missile guidance and control systems, anti-lock braking system, airbag deployment, voip, stock market website.

What is RTOS (Real Time Operating System):

To run, real-time applications you must use a real-time operating system (RTOS).
It is an OS, specially designed to run applications with very precise timing and high degree of reliability.

To be considered as "real-time", an operating system must have a known maximum time of each of the critical operations that it performs. 
Some of these operations include:
- Handling of interrupts and internal system exceptions
- Handling of Critical Sections
- Scheduling Mechanism, etc.

RTOS vs GPOS
GPOS: Linux, Windows, iOS, Android
RTOS: VxWorks, QNX, FreeRTOS, Integrity

Embedded OS: iOS, Android

Embedded OS + Real Time OS = Embedded Real-Time OS (QNX, FreeRTOS, VxWorks)
----------------------------------------------------------------------------------
RTOS vs GPOS: Task Scheduling

GPOS Task Scheduling:
. GPOS is programmed to handle scheduling in such a way that it manages to achieve high throughput.
. Throughput is defined as the total number of processes that complete their execution per unit time.
  Sometimes execution of a high priority process will get delayed in order to serve 5 or 6 low priority tasks. 
. High throughput is achieved by serving 5 low priority tasks,
  rather than by serving a single high priority one.
. So, if 5 or 6 low priority Applications are waiting to run, then the GPOS may delay 1 or 2 high priority tasks 
  in order to increase the throughput.
. In a GPOS, the scheduler typically uses a fairness policy to dispatch threads and processes onto the CPU.
  Such a policy enables the high overall throughput required by Desktop and Server applications, but offers no 
  guarantees that high-priority, time critical threads or processes will execute in preference to lower-priority threads.

RTOS Task Scheduling:
In RTOS, threads execute in the order of their priority. If a high-priority thread becomes ready to run, it will take over 
the CPU from any lower-priority thread that may be executing. Here a high priority thread gets executed over the low priority 
ones. All 'low priority thread execution' will get paused. A high priority thread execution will get overridden only if a
request comes from an even higher priority thread.

RTOS may yield less throughput than GPOS because it always favors the high priority task to execute first, but that does not 
mean it has poor throughput. A quality RTOS will still deliver decent overall throughput but can sacrifice throughput for being 
deterministic or to achieve time predictability.

For RTOS, achieving predictability or time deterministic nature is more important than throughput, but for GPOS achieving higher 
throughput for user convenience is more important.
----------------------------------------------------------------------------------
RTOS vs GPOS: Task Switching Latency

In Computing, Latency means "the time that elapses between a stimulus and the response to it".
Task switching latency means, that time gap between "a triggering of an event and the time at which the task which takes care of 
that event is allowed to run on the CPU".

t1 = Event occured (ex. Crash detection)
t2 = A task is made to run on CPU (ex. air bag deployment task)
task switching latency = t2 - t1.

In GPOS, Task Switching latency may vary significantly.
In RTOS, Task switching latency remains almost constant because it is always time bounded.

Similarly, Interrupt Latency is the timegap between the IRQ occuring and the ISR executing. Scheduling Latency is the timegap between 
the ISR finishing and the next task resuming. Both the interrupt latency and scheduling latency of the RTOS is as small as possible and 
time bounded. But in the case of GPOS, due to increase in system load, these parameters may vary significantly.
----------------------------------------------------------------------------------
RTOS vs GPOS: Priority Inversion

Example: 
You are a low priority vehicle crossing a 4-way intersection and are stopped in the middle of the intersection due to a sudden 
backup/stoppage of medium priority cars in front of you. Now an ambulance (high priority) vehicle is trying to cross perpindular and now 
the LP vehicle is blocking it. Despite being the HP Vehicle, it is not able to proceed because the intersection is occupied by the 
LP vehicle, but the LP vehicle is not able to proceed due to the traffic jam. In this situation, a HP vehicle is waiting for LP vehicle 
to run and clear the way. This is referred to as "priority inversion", which means a HP vehicle is acting like a LP and LP vehicle is 
acting like a HP. 

Let's also say that this intersection area is a "shared resource".

LP Task has acquired the shared resource now by using the key, but it is not getting a chance to run on the CPU to give up the key. That 
means the shared resource is locked by LP task indefinitely which is also required by the HP task to proceed

RTOS can create paths on the fly to resolve this issue (re-scheduling) or by temporarily changing the LP as highest priority amongst all 
other tasks so it can run and release the key, then later restoring its original priority.

In GPOS, priority inversion effects are in-significant. In RTOS they must be solved.

What are the features that an RTOS has but a GPOS doesn't?
1. Priority based preemptive scheduling mechanism
2. No or very short critical sections which disables the preemption
3. Priority inversion avoidance
4. Bounded interrupt latency
5. Bounded scheduling latency, etc
----------------------------------------------------------------------------------
What is Multi-Tasking?
Options:
Multi-tasking with time-slicing (20 min for each task throughout day : ex. Eat, email, call, notes, schedule, call)
Offload work to assistants to carry out duty

Application and Tasks
Temperature Monitoring application:
Task1: Sensor data gathering
Task2: Updating display
Task3: User input processing

How do you run multiple tasks on a processor which has only a single core?
Running multiple tasks on a processor is accomplished by a 'scheduler'

Or, if your processor cores >= number of tasks, a scheduler is not required because each task can be executed on individual cores.
----------------------------------------------------------------------------------
Adding FreeRTOS Kernel to your project:
Manually (Non CMSIS RTOS) or STM32Cube Device Config Tool (CMSIS RTOS API)
  CMSIS-RTOS API is a generic RTOS interface for ARM Cortex-M processor-based devices
  Device Config Tool -> Middleware -> FreeRTOS -> CMSIS_V1 or CMSIS_V2 Interface

Layers:
Application Code (Main, Thread, Interrupt)
CMSIS_RTOS API (Obj def via macros, function call translations)
Real Time Kernel (3rd Party)

Example:
Application ( osThreadCreate() )
	v
CMSIS-CORE layer ( vTaskCreate() )
	v
FreeRTOS

osThreadCreate() API provided by CMSIS-RTOS layer to create an RTOS Task (Independent of an underlying RTOS)
vTaskCreate() Actual API provided by FreeRTOS to create a Task (Specific)
----------------------------------------------------------------------------------
Time Base Source Selection:
FreeRTOS uses ARM Cortex Mx processor's internal systick timer as its time base (RTOS ticking)
STM32 Cube HAL layer also by default uses systick timer as its time base source.
If you are using both freeRTOS and STM32 HAL layer in your project, there will be a conflict to use a timebase source.
To resolve this, it is strongly recommended to use STM32 cube HAL layer timebase source other than systick timer (use any timer 
peripheral of the microcontroller)
----------------------------------------------------------------------------------
What is a Task?

__Task Creation__:

BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
			const char* const pcName,
			unsigned short usStackDepth,
			void *pvParameters,
			uBaseType_t uxPriority,
			TaskHandle_t *pxCreatedTask
		      );


__Task Implementation__:

void vATaskFunction(void *pvParameters) {
/* Variables can be declared just as per a normal function. Each instance of a task created using this function will ahve its own copy
of a the iVariableExample variable. This would not be true if the variable was declared static - in which case only one copy of the 
variable would exist
and this copy would be shared by each created instance of the task. */
int iVariableExample = 0;

     /* A task will normally be implemented as in infinite loop */
     for(;;) {
	//-- Task application code here --
     }

     /* Should the task implementation ever break out of the above loop, then the task must be deleted before reaching the end of this function.
     The NULL parameter passed to vTaskDelete() function indicates that the task to be deleted is the calling (this) task */
     vTaskDelete(NULL);
}

static void task1_handler(void* parameters) {
	/* These local variables will get created in the Task's private stack memory. More variables, more stack consumption */
	int var1, var2;

	/* This static variable will not be created in the Task's private stack memory */
	static int staticvar1;

	while(1) {
		
	}

	/* Clean up before exiting */
	vTaskDelete(NULL);
}
Each Task carries its own Stack Memory where it saves local variables. Multiple tasks can share the same task function and have separate instances 
of the local variables defined inside (UNLESS it is declared static, then it is a single global variable common between both tasks).
----------------------------------------------------------------------------------
FreeRTOS task creation API:

//This API creates a new FreeRTOS Task using dynamic memory allocation and adds the newly created task (TCB) to ready queue of the kernel
BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, 			//Address of associated task handler
			const char* const pcName,			//Descriptive name to identify the task
			const configSTACK_DEPTH_TYPE usStackDepth,	//Amount of stack memory allocated to this task (memory in words not bytes)
			void* const pvParameters,			//Pointer of the data which needs to be passed to the task handler once it gets scheduled
			UBaseType_t uxPriority,				//Task priority value
			TaskHandle_t* const pxCreatedTask		//Used to save the task handle (an address of the task created)
		      );

ARM Cortex Mx stack operation model (Full descending stack)
	usStackDepth * (stack_width / 8) = Memory size (in bytes)
	100 * (16-bit stack_width / 8) = 200 bytes
	400 * (32-bit stack_width / 8) = 1600 bytes
The memory size allocation for usStackDepth * stack_width must not exceed the maximum value that can be contained in a variable of type size_t.

Word:
Is the max size of the data which can be accessed (load/store) by the processor in a single clock cycle using a single instruction.
Processor design also offers native support (register width, bus width) to load/store word-sized data.
Word size could be 8bit/16bit/32bit or more, depending on the processor design. For ARM Cortex Mx MCUs, word size = 32bits

__ configSTACK_DEPTH_TYPE __

Previously: 	UBaseType_t usStackDepth -> uint8_t usStackDepth (8bit MCUs)
Updated to: 	configSTACK_DEPTH_TYPE usStackDepth
	    	#define configSTACK_DEPTH_TYPE uint16_t (FreeRTOS.h)
----------------------------------------------------------------------------------
Task Priorities:
. A priority value comes into picture when there are 2 or more tasks in the system.
. Priority value helps the schedule to decide which task should run first on the processor.
. Lower the priority value, lesser the task priority (urgency)
. In freeRTOS, each task can be assigned a priority value from 0 to (configMAX_PRIORITIES - 1) where configMAX_PRIORITIES may be defined in 
  FreeRTOSConfig.h
. You must decide configMAX_PRIORITIES as per your application need. Using too many task priority values could lead to RAM's overconsumption. 
  If many tasks are allowed to execute with varying task priorities, it may decrease the system's overall performance.
. Limit configMAX_PRIORITIES to 5, unless you have a valid reason to increase this.
----------------------------------------------------------------------------------
Scheduling:
Now, we have created 2 tasks, which are in the ready task list of the freeRTOS (READY state).
Tasks will be dispatched to run on the CPU by the scheduler.
A Scheduler is a piece of code that is part of the freeRTOS kernel, which runs in the privileged mode of the processor.
The scheduler should be invoked by calling the vTaskStartScheduler() API provided by freeRTOS.

Scheduling policy:
Scheduler will schedule tasks to run on the CPU according to the policy configured:
1) Pre-emptive scheduling 2) Co-operative scheduling
configUSER_PREEMPTION = 1 for pre-emptive scheduling
configUSER_PREEMPTION = 0 for co-operative scheduling

Pre-emptive scheduling:
Pre-emption means replacing a task with another task.
During pre-emption, the running task is made to give up the processor even if it hasn't finished the work. The scheduler does this to run 
some other tasks of the application.
The task which gave up the processor simply returns to the ready state.

Round-robin pre-emptive scheduling:
Scheduling tasks without priority (also known as cyclic executive).
Time slices are assigned to each task in equal portions and in circular order.
Context switching between tasks involves pre-emption.

#define configTICK_RATE_HZ((TickType_t) 1000)

Priority based pre-emptive scheduling:
Tasks are scheduled to run on the CPU based on their priority. A task with higher priority will be made to run on the CPU forever unless the 
task gets deleted/blocked/suspended or leaves voluntarily to give chance for others.

Co-operative scheduling:
A Task cooperates with other tasks by explicitly giving up the processor (Processor yielding)
There is no 'pre-emption' of the tasks by the scheduler. That is, the running task will never be interrupted by the scheduler.
The RTOS tick interrupt doesn't cause any pre-emption, but the tick interrupts are still needed to keep track of the kernel's real-time tick value.
Tasks give up the CPU when they are done or periodically or blocked/suspended waiting for a resource.
----------------------------------------------------------------------------------
Behind the scene task creation:
What happens when you create a task?
Total RAM(SRAM1 + SRAM2) -> 112 + 16 = 128KiB

RAM is comprised of Heap and Kernel stack
Heap (configTOTAL_HEAP_SIZE)   and Kernel Stack (RAM space is used for Global data, arrays, static variables, etc)

Dynamically Created kernel objects
When xTaskCreate() is called, Task-1 TCB (Task Control Block) and Task-1's stack memory (Stack-1) will be allocated in the heap global space.
A Semaphore created with xSemaphoreCreateBinary() would have its SCB (Semaphore Control Block) allocated in the heap global space.
A Queue created with xQueueCreate() would have its QCB (Queue Control Block) and Item List allocated in the heap global space.

When xTaskCreate() is called, 3 things will happen:
1) The TCB structure will be created in RAM (heap section) and initialized. pxTopOfStack will be a pointer to the top of the Stack.
2) Dedicated stack memory will be created for a task and initialized. This stack memory will be tracked using PSP register of the ARM Cortex Mx 
   processor.
3) Task will be put under "Ready" list for scheduler to pick. Task Ready list maintained by freeRTOS kernel.
----------------------------------------------------------------------------------
Segger Trace Tool Integration:
Download below tools:
1. SEGGER SystemView software (host)
2. SEGGER SystemView target source files (target)
3. SEGGER ST-Link Reflash utility (not used)
4. SEGGER J-Link software package v5.12b or later (not used, required if using 3rd)
5. SystemView user manual

Segger SystemView is a software toolkit which is used to analyze the embedded software behavior running on your target.
The embedded software may contain embedded OS or RTOS or it could be a non-OS based application.

Example: FreeRTOS application
You can analyze how many tasks are running and how much duration they consume on the CPU.
ISR entry and exit timings and duration of the run on the CPU.
You can analyze other behavior of tasks: like blocking, unblocking, notifying, yielding, etc.
You can analyze CPU idle time so that you can think of sending CPU to sleep mode.
Total runtime behavior of the application.

It sheds light on what exactly happened in which order, which interrupt has triggered which task switch, which interrupt and task has called 
which API function of the underlying RTOS. SystemView should be used to verify that the embedded system behaves as expected and can be used 
to find problems and inefficiencies, such as superfluous and spurious interrupts, and unexpected task changes.

SystemView toolkit comes in 2 parts:
1) PC visualization software: SystemView Host software
2) SystemView target codes (used to collect the target events and sending back to PC visualization software)

SystemView Visualization modes:
1) Real time recording (continuous recording)
With a SEGGER J-Link and its Real Time Transfer (RTT) technology SystemView can continuously record data, and analyze and visualize it in real time.
Real time mode can be achieved via ST-link instead of J-link. For that, J-link firmware has to be flashed on ST-link circuitry of STM32 boards.
2) Single-shot recording
There is no need for JLINK or STLINK debugger for this mode.
In single-shot mode, the recording is started manually in the application, which allows recording only specific parts of interest.


			REAL-TIME RECORDING (note the differences in signal directions)
Target System					Host System(PC)
------------ Application ----------------|		SystemViewer
     |		  v		v	 |	             ^
User events	 RTOS	Middleware    		 |           |
and printf        |      (e.g. IP stack) |           |
     |            v             |        |           |               
     |_____> SystemView API <___|        |           |
		          v			 			 |		     v
				RTT API			 		 |	   J-Link RTT DLL API
				  |			 	   		 |			 ^
------------------|----------------------|		     |
Target RAM        v			 	  					 v
	RTT Buffer (Software FIFO)	 		        J-Link DLL
		  ^                                          ^
		  |________________> J-Link <________________|


			SINGLE-SHOT RECORDING (note the differences in signal directions)
Target System					Host System(PC)
------------ Application ----------------|		SystemViewer
     |		  v		   v	 		     |	         ^
User events	 RTOS	Middleware           |           |
and printf        |      (e.g. IP stack) |           |
     |            v             |        |		     |              
     |_____> SystemView API <___|        |           |
		          v		 				 |		     |
	           RTT API		 			 |  SystemView Data file (*.SVDat)
    		      |			 			 |		     ^
------------------|----------------------|		     |
Target RAM        v			 			 		     |
	RTT Buffer (Software FIFO)	 		  	 	 Debugger
		  |                                          ^
		  |______> Any debug probe/interface ________|

When no J-Link is used, SEGGER SystemView can be used to record data until its target buffer is filled.
In single-shot mode, the recording is started manually in the application, which allows recording only specific parts of interest.

Step 1:
Adding SEGGER SystemView target sources to the project
- Download SystemView target sources and extract it
- Create the folders as shown below in your FreeRTOS project.
- Do the path settings for the include files of SEGGER in the IDE.

Step 2: Patching FreeRTOS files
You need to patch some of the FreeRTOS files with patch file given
- Right click ThirdParty (select Team > Apply Patch) and select it through the workspace and hit accept.

Step 3: FreeRTOSConfig.h Settings
- SEGGER_SYSVIEW_FREERTOS.h header must be included at the end of FreeRTOSConfig.h or above every include of FreeRTOS.h. It defines the 
  trace macros to create SYSTEMVIEW events
- In FreeRTOSConfig.h include the below macros
	#define INCLUDE_xTaskGetIdleTaskHandle 1
	#define INCLUDE_pxTaskGetStackStart 1

Step 4: MCU and Project specific settings:
- Mention which processor core your MCU is using in SEGGER_SYSVIEW_ConfDefaults.h
- Do SystemView buffer size configuration in SEGGER_SYSVIEW_ConfDefaults.h (SEGGER_SYSVIEW_RTT_BUFFER_SIZE)
- Configure some of the application specific information in SEGGER_SYSVIEW_Config_FreeRTOS.c

Step 5: Enable the ARM Cortex M3/M4 Cycle Counter
- This is required to maintain the time stamp information of application events. SystemView will use the Cycle counter register value to 
  keep the time stamp information of the events.
- DWT_CYCCNT register of ARM Cortex M3/M4 processor stores the number of clock cycles that happened after the processor's reset.
	- To use this register, DWT_CTRL register must be enabled first (DWT_CTRL |= (1 << 0)).
- By default, this register is disabled.

Step 6: Start the recording of events
- To start the recordings of your FreeRTOS application, call the below SEGGER APIs
	- SEGGER_SYSVIEW_Conf();
	- SEGGER_SYSVIEW_Start();
- The SEGGER SystemView events recording starts only when you call SEGGER_SYSVIEW_Start() from main.c.

Step 7: Compile and Debug
- Make sure that include path settings are set
- Compile and flash your FreeRTOS + SystemView application
- Go to debugging mode using your IDE
- Hit run and then pause after a couple of seconds

Step 8: Collect the recorded data (RTT buffer)
- You can do this via continuous recording or single-shot recording
- Single-shot recording:
	- Get the SystemView RTT buffer address and the number of bytes used. (Normally _SEGGER_RTT.aUp[1].pBuffer and _SEGGER_RTT.aUp[1].WrOff).
	- Take the memory dump to a file
	- Save the file with .SVDat extension
	- Use that file to load into SystemView HOST software to analyze the events.

Preemptive Scheduling:
	To preemt a task, the SysTick handler is called which triggers the scheduler. This adds extra execution time between tasks for both SysTick 
	handler and Scheduler.
Cooperative Scheduling:
	Cooperative Scheduling involves a task yielding to another. The SysTick timer will still occur, but it will no longer be used to trigger the 
	scheduler, thus freeing up CPU time.

In this project, there are two _write() functions that exist. One is located in the /core/src/syscalls.c and is defined with a weak attribute, 
while the other is in /ThirdParty/SEGGER/SEGGER/Syscalls/SEGGER_RTT_Syscalls_GCC.c which overrides the weak function.

To view print statements in SEGGER SystemView, you have to use SEGGER's version of printf listed in the documentation : SEGGER_SYSVIEW_PrintfTarget()
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
IDLE Task and Timer Svc Task of FreeRTOS:

Idle Task:
The Idle task is created automatically when the RTOS scheduler is started to ensure there is always at least one task that is able to run.
It is created at the lowest possible priority to ensure it does not use any CPU time if there are higher priority application tasks in the ready state.
The idle task is responsible for freeing memory allocated by the RTOS to tasks that have been deleted.
When there are no tasks running, the Idle task will always run on the CPU.
You can give an application hook function in the idle task to send the CPU to low power mode when there are no useful tasks executing.

Timer Services Task (Timer_svc)
- This is also called as timer daemon task.
- The timer daemon task deals with "Software timers"
- This task is created automatically when the scheduler is started and if configUSE_TIMERS=1 in FreeRTOSConfig.h
- The RTOS uses this daemon to manage FreeRTOS software timers and nothing else.
- If you don't use software timers in your FreeRTOS applications, then you need to use this Timer daemon task. For that just make configUSE_TIMERS=0 
  in FreeRTOSConfig.h
- All software timer callback functions execute in the context of the timer daemon task.
----------------------------------------------------------------------------------
	FreeRTOS Scheduler
FreeRTOS Scheduler Implementation:
- In FreeRTOS, the scheduler code is actually a combination of FreeRTOS Generic code (tasks.c) + Architecture specific codes (port.c)

Architecture specific codes responsible to achieve scheduling of tasks:
- All architecture specific codes and configurations are implemented in port.c and portmacro.h
- If you are using ARM Cortex Mx processor, then you should be able to locate the below interrupt handlers in port.c which are part of the scheduler 
  implementation of freeRTOS.

vPortSVCHandler() //Used to launch the very first task. Triggered by SVC instruction
xPortPendSVHandler() //Used to achieve the context switching between tasks. Triggered by pending the PendSV System exception of ARM
xPortSysTickHandler() //This implements the RTOS Tick management. Triggered periodically by Systick timer of ARM Cortex Mx processor.

The collection of these Handlers make up a Scheduler.

vTaskStartScheduler()
- This is implemented in tasks.c of FreeRTOS kernel and used to start the RTOS scheduler.
- Remember that after calling this function only the scheduler code is initialized and all the Arch. specific interrupts will be activated.
- This function also creates the idle and timer daemon task.
- This function calls xPortStartScheduler() to do the Arch. Specific Initializations

vTaskStartScheduler() //Generic Code for all Arch.
   |
   V
xPortStartScheduler() //Arch. Specific code
   |-> Configuring the SysTick timer to issue interrupts at desired rate (as configured in the config item configTICK_RATE_HZ in FreeRTOSConfig.h)
   |-> Configures the priority for PendSV and Systick interrupts.
   |-> Starts the first task by executing the SVC instruction
----------------------------------------------------------------------------------
	FreeRTOS and ARM Cortex Mx Arch. Specific Details

FreeRTOS Kernel Interrupts:
When FreeRTOS runs on ARM Cortex Mx Processor based MCU, below interrupts are used to implement the Scheduling of tasks.
1. SVC Interrupt (SVC handler will be used to launch the very first Task)
2. PendSV Interrupt (PendSV handler is used to carry out context switching between tasks)
3. SysTick Interrupt (SysTick handler implements the RTOS Tick Management)
If SysTick interrupt is used for some other purpose in your application, then you may use any other available timer peripheral.
All interrupts are configured at the lowest interrupt priority possible.

RTOS Tick (The heart beat) #define configTICK_RATE_HZ ((portTickType)1000) //every 1ms
RTOS Ticking is implemented using timer hardware of the MCU

The RTOS Tick - Why it is needed?
- The simple answer is to keep track of time elapsed.
- There is a global variable called "xTickCount", and it is incremented by one whenever tick interrupt occurs
- RTOS Ticking is implemented using SysTick timer of the ARM Cortex Mx processor
- Tick interrupt happens at the rate of configTICK_RATE_HZ configured in the FreeRTOSConfig.h

vTaskDelay(100) // Task-1 is going to sleep for 100ms
That means, the kernel has to wake up this task and schedule it on the CPU after 100ms.
So, how do you think freeRTOS kernel tracks the completion of 100ms?
Its because of maintaining the global tick count and incrementing it for every tick interrupt from SysTick timer.

The RTOS Tick is also used for Context Switching to the next potential Task.
1. The tick ISR runs
2. All the ready state tasks are scanned
3. Determines which is the next potential task to run
4. If found, triggers the context switching by pending the PendSV interrupt
5. The PendSV handler takes care of switching out of old task and switching in new task.

Who configures RTOS tick timer (SysTick)?

vTaskStartScheduler() //Generic Code for all Arch. (tasks.c)
   |
   V
xPortStartScheduler() //Arch. Specific code (port.c)
   |-> First initialize the SysTick interrupt priority to be the lowest possible.
   |-> Loads the rate value to SysTick timer. (configTick_RATE_HZ)
   |-> Enables the SysTick timer interrupt and starts the timer.

RTOS Tick Configuration (port.c):
configSYSTICK_CLOCK_HZ = configCPU_CLK_HZ
If configCPU_CLK_HZ = 84000000 (i.e. 84MHz)
and configTICK_RATE_HZ = 1000Hz
Then, portSYSTICK_NVIC_LOAD_REG = (84000000 / 1000) - 1 = 83999
The SysTick timer when started, counts down from 83999 to 0. It generates an interrupt when the count value reaches 0 and again reloads the 
load count value.
So, 83999 is the systick load value required to generate an interrupt for every 1ms(1000Hz)

Summary of RTOS Tick ISR (SysTick interrupt triggering the SysTick Handler):
1) SysTick Interrupt triggered
   - Tick ISR Runs ( xPortSysTickHandler() )
   - portDISABLE_INTERRUPTS();  //nothing should preempt systick handler when running
   - calls xTaskIncrementTick() 
2) xTaskIncrementTick()
   - xTickCount++
   - checks to see if the new tick value will cause any tasks to be unblocked or checks for any potential available tasks in the ready list
   - calls application hook function if enabled
   - returns TRUE if context switch is required
3) Return from xTaskIncrementTick() function and evaluate if TRUE
   - Pend the PendSV handler if TRUE
	- portENABLE_INTERRUPTS();
4) Exit from ISR
In SystemView 001.SVdat, it takes roughly 5.8us to complete the SysTick handler call.
Once the SysTick handler exits, the PendSV handler (shown as scheduler in SystemView -- because it functions as a type of scheduler) runs.
----------------------------------------------------------------------------------
Context Switching:

PendSV_Handler (Context Switching):
- Context switching is a process of switching out of one task and switching into another task on the CPU to execute.
- In RTOS, Context Switching is taken care of by the Scheduler.
- In FreeRTOS, Context Switching is taken care of by the PendSV Handler found in port.c
- Whether context switch should happen or not depends upon the scheduling policy of the scheduler.
- If the scheduler is priority based pre-emptive scheduler, then for every RTOS tick interrupt, the scheduler will compare the priority
  of the running task with the priority of the ready tasks list. If there is any ready task whos priority is higher than the running task, 
  then the context switch will occur.
- On FreeRTOS you can also trigger context switch manually using taskYIELD() macro
- Context switch also happens immediately whenever a new task unblocks and its priority is higher than the currently running task.

Task State:
- When a task executes on the processor it utilizes
   - Processor core registers
   - If a task wants to do any push and pop operations (during function call) then it uses its own dedicated stack memory.
State of the task = Contents of the processor core registers + stack contents

User task uses PSP, kernel uses MSP.
SP points to the correct stack pointer depending on if a task or an isr is running

Stacks:
There are (mainly) 2 different Stack Memories during runtime of FreeRTOS based applications

1) 	| Task's Private Stack (Process Stack)
	|
SP(PSP)	|
------->| Push and POP to this stack area is tracked 
	|          by PSP Register of ARM.
	| When Task executes it does PUSH and POP here.

2) 	| 	Kernel Stack (Main Stack)
	|
SP(MSP)	|
------->| Push and POP to this stack area is tracked 
	|          by MSP Register of ARM.
	| When ISR executes it does PUSH and POP here.

RAM_END - - - - - - - - - - - - - - RAM (112kB) - - - - - - - - - - - - - - - - RAM_START
	     Heap	       |       Kernel Stack	   |	Global Space		|
<----configTOTAL_HEAP_SIZE---->| This stack area is 	   | Global space to hold	|
Task-B	Task-A	Task-C	Task-D | utilized when interrupt   | global variables,		|
Stack	Stack	Stack	Stack  | handlers do PUSH and POP  | static variables etc	|
TCB-B	TCB-A	TCB-C	TCB-D  |			   |			  	|
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


Task Switching out procedure:
Before task is switched out, the following things occur:
1) Processor core registers R0,R1,R2,R3,R12,LR,PC,xPSR (stack frame) are saved on to the task's private stack automatically by thhe
   processor SysTick interrupt entry sequence.
2) If Context Switch is required then SysTick timer will pend the PendSV Exception and PendSV handler runs.
3) Processor core registers (R4-R11, R14) have to be saved manually on the task's private stack memory (saving the context)
4) Save the new top of stack value (PSP) into first member of the TCB
5) Select the next potential Task to execute on the CPU. Taken care by vTaskSwitchContext() implemented in tasks.c
//taskSELECT_HIGHEST_PRIORITY_TASK();

SVC exception is only triggered once in FreeRTOS, when scheduling the very first task.
Task yielding depends on the PendSV exception of the ARM Cortex M Processor.
Default priority of the PendSV exception in FreeRTOS assuming NVIC_PRIO_BITS = 4 is : 0xF0 (lowest possible priority level in this case).
By default, the pendsv exception will be the lowest possible priority.
PendSV, SVC, and SysTick exceptions are configured in vPortStartScheduler()
SysTick is a timer engine located inside the ARM Cortex M processor.

Q. if configTICK_RATE_HZ = 1000 Hz, whats the value fed in to the SysTick counter ?
Assume : MCU System Clock is 16Mhz
A. (16000) - 1
SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1

----------------------------------------------------------------------------------
SEGGER SystemView UART based recording:

Real Time Recording (Continuous Recording)
. Need J-link based debug probe
. ST link debug probe also can be used by changing ST link firmware to J-link (ST-link reflash utility provided by SEGGER)
. Not so useful for us because when ST link firmware is removed, we wont be able to debug the application using STM32CUBEIDE
In SEGGER_SYSVIEW_Conf.h, #define SEGGER_UART_REC 0	//change to 1 to enable UART based continuous recording
Change Clock Frequency to max (180MHz) in the Device Configuration Tool to support higher baud rates.
HCLK set to 180MHZ, APB1 Prescalar set to 4, APB2 Prescaler set to 2
SEGGER_SYSVIEW_Start() is done in the segger_uart.c file, so it can be removed in main.c if using continuous recording.
----------------------------------------------------------------------------------
Exercise: 002LED_Tasks
Toggle 3 LEDs of the STM32F446RE board with the durations:
Task1: LED_RED (1000ms toggle) PB5
Task2: LED_YELLOW (800ms toggle) PB8
Task3: LED_BLUE (600ms toggle) PB9
Task4: LED_GREEN (400ms toggle) PB10
Create 3 FreeRTOS tasks of the same priority to handle three different LEDs.

No sharing of resources. Single-core processor.

//Blocking GPOS method
int main(void) {
	while(1) {
		LED_Toggle(LED1);
		LED_Toggle(LED2);
		LED_Toggle(LED3);
		Delay(400); //blocking delay
		LED_Toggle(LED3);
		Delay(400);
		LED_Toggle(LED2);
		LED_Toggle(LED3);
		Delay(200);
		LED_Toggle(LED1);
		Delay(200);
		LED_Toggle(LED3);
		Delay(400);
		LED_Toggle(LED2);
		LED_Toggle(LED3);
		Delay(400);
		LED_Toggle(LED1);
		LED_Toggle(LED3);
		Delay(400);
		LED_Toggle(LED2);
		LED_Toggle(LED3);
		//Continues
	}
}

//1) Handling of other useful work becomes tedious
//2) Complex logic
//3) Uses blocking delay
//4) Consumes more power (processor is always engaged)


//instead, could use a timer ISR:

void timer_interrupt_handler(TIM_HandleTypeDef *htim) {
	static int led1_ctrl, led2_ctrl, led3_ctrl;

	led1_ctrl++;
	led2_ctrl++;
	led3_ctrl++;
	
	if(led1_ctrl == 10) {
		LED_Toggle(LED1_PIN);
		led1_ctrl = 0;
	}

	if(led2_ctrl == 8) {
		LED_Toggle(LED2_PIN);
		led2_ctrl = 0;		
	}

	if(led3_ctrl == 2) {
		LED_Toggle(LED3_PIN);
		led3_ctrl = 0;
	}
}

Thread mode (Make un-privileged access)
User level code usually runs in thread mode of the processor.

Handler mode (privileged access)
ISR/Exception handlers always runs in handler mode of the processor

*Processor always starts in thread mode with privileged access level



Instead we will use an RTOS method to handle the timing of the LEDS

Runs in thread mode of the processor (CPU time sharing is achieved by the scheduler)
	context-switching by scheduler
Task-1	--->	Task-2	 --->	Task-3	--->	Task-4
LED_RED		LED_YELLOW	LED_BLUE	LED_GREEN

1) All user level code (Tasks) run in thread mode of the processor
2) Task management is required (provided by RTOS kernel)
3) Using priority among tasks can achieve prioritized task management
4) Low power (CPU is not always engaged)

Project Setup (CubeIDE Project Manager/Code Generation)
- Go to SYS -> Debug (Disable) Timebase Source (TIM6 instead of SYSTick)
- NVIC
   - NVIC -> Priority Group: 4 bits for pre-emption priority 0 bits for subpriority
   - Code Generation -> Generate IRQ Handler: Unselect: System service call via SWI instruciton, pendable request for system service, 
     system tick timer

In Core/Src/stm32f4xx_hal_msp.c
- Call vInitPrioGroupValue(); from HAL_MspInit()
- include "FreeRTOS.h"
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
Task States

Top Level Task States - Simplistic Model

All other tasks which are not currently running on the CPU are in the "Not-Running State"
Only one task can be in the Running state at a given point in time.
Not-Running  <--->  Running

A "Not-running state" means the task is either suspended, ready or blocked states.



				        vTaskSuspend()
    |--------------> Suspended <---------------------------------|
    |		           |  |					 					 |
    |   vTaskSuspend() |  | vTaskResume()		 			     |
    |    	           |  |	         Schedule			 		 |
    |  		           |  v   ---------------------->            |
    |	      -------> Ready <-----------------------  Running --|
    | Create new task  ^  ^	   Pre-empt/Yield	  				 |
    |		           |  |				  						 |
    |	         Event |  | xTaskAbortDelay()		  			 | Blocking API
    |		           |  |				  						 |    called
    |--------------- Blocked <-----------------------------------|

RUNNING state:
. When a task is currently executing on the processor, it is said to be in the RUNNING state.
. The number of tasks that can be concurrently in the RUNNING state is less than or equal to the number of cores on the processor.
	- single-core processor can only run one task at a time.

READY state:
. Tasks that can run on the CPU when the scheduler schedules them.
. The scheduler may not scheduler the ready state task to run on the CPU if some higher priority task is currently executing on the CPU.
. In FreeRTOS, whenever a new task is created, it enters the READY state.

BLOCKED state:
. A task can leave a CPU from the RUNNING state and chooses not to run on the CPU until an internal or external event is met. This state is the 
  BLOCKED state.
. When a task is in the BLOCKED state, it wont consume any CPU time.
. In FreeRTOS, there is an API called vTaskDelay(500). If a task calls this function, then it will enter a BLOCKED state for 500 RTOS ticks, 
  after which is unblocks and enters the READY state (an internal temporal event)
. A task can also block waiting on an external event, like data arrival to the queue, nonavailability of lock in this case of mutex or semaphore, etc.
. Task in a BLOCKED state has a timeout period; after the timeout period, it unblocks and enters the ready state even if the event for which it is 
  waiting has not occurred.

Advantages of blocking:
1. To implement the blocking Delay - for example, a task may enter the blocked state to wait for 10 milliseconds to pass.
2. For synchronization - for example, a task may enter the blocked state to wait for data to arrive on a queue. When another task or interrupt fills 
   up the queue, the blocked task unblocks.

FreeRTOS queues, binary sempahores, counting semaphores, recursive semaphores, and mutexes can all be used to implement synchronization, and thus 
they support blocking of the task.

Blocking Delay APIs:
vTaskDelay()
vTaskDelayUntil()

Why use them?
1. Delay a task without engaging the processor (replacement for "for/while" loop based crude delay implementation)
2. Implementation of periodic tasks

Queues, Semaphores, Mutex are all kernel objects that support APIs which can block a task during operation.

SUSPENDED state:
. A task enters the suspended state when it or another task calls vTaskSuspend(task_handle);
. A suspended task will not enter READY state unless some other running tasks cancel the suspension by calling the API 
  vTaskResume(task_handle_of_suspended_task);
. Unlike blocked state task, a task in the SUSPENDED state doesn't have a timeout period.
. Task in READY state can enter suspended state directly if some other running task calls vTaskSuspend(task_handle); using task 
  handle of the READY state task.
----------------------------------------------------------------------------------
FreeRTOS Blocking Task delay APIs:
1. void vTaskDelay(portTickType xTicksToDelay);
2. void vTaskDelayUntil(TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement);

Generate delay of ~10ms

for(int i = 0; i < 5000; i++);  //This code runs on the CPU continuously for 10ms, starving other lower priority tasks. Not a preferred method.

vTaskDelay(10);  //This is a blocking delay API that blocks the task for 10ms. For the next 10ms, other lower priority tasks of the system can 
                 //run. After 10ms, the task wakes up and enters the READY state.

Different types of tasks:
1) Continuous Task
2) Periodic Task
3) Aperiodic Task

Periodic Task:
. Task which executes with a fixed execution period in the timeline
. To achieve fixed periodicity of a task, use vTaskDelayUntil() instead of vTaskDelay()
. Fixed periodicity (task waking up and moving to ready state) is not guaranteed if vTaskDelay() is used to implement the periodic tasks.

Milliseconds to ticks conversion
xTicksToWait = (xTimeInMs * configTICK_RATE_HZ) / 1000

Example:
If configTICK_RATE_HZ is 500, then systick interrupt (RTOS tick) is going to happen for every 2ms. So, 500ms delay is equiv to 250 RTOS ticks.

Conclusion:
If you want to implement a delay inside your task function, use vTaskDelay() instead of crude for loop-based delay.
If you want to implement a task that must execute with a fixed execution period (periodic task), then use vTaskDelayUntil();
----------------------------------------------------------------------------------
Exercise: 003LED_Block_Tasks
Toggle 4 LEDs of the STM32F446RE board with the following durations.
Create 4 FreeRTOS tasks of the same priority to handle 4 different LEDs.
Use vTaskDelay() for delay implementation

LED_RED (Task-1) 1000ms
LED_YELLOW (Task-2) 800ms
LED_BLUE (Task-3) 600ms
LED_GREEN (Task-4) 400ms
----------------------------------------------------------------------------------
Exercise: 004LED_Periodic_Tasks
Toggle 4 LEDs of the STM32F446RE board with the following durations.
Create 4 FreeRTOS periodic tasks of the same priority to handle 4 different LEDs.
Use vTaskDelayUntil() for delay implementation

LED_RED (Task-1) 1000ms
LED_YELLOW (Task-2) 800ms
LED_BLUE (Task-3) 600ms
LED_GREEN (Task-4) 400ms
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
FreeRTOS Task Notification

Each RTOS task has a 32-bit notification value which is initialized to zero when the RTOS task is created.

An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's 
notification value in a number of different ways. For example, a notification may overwrite the receiving task's notification value, or just 
set one or more bits in the receiving task's notification value.

Wait and Notify APIs:
xTaskNotifyWait()
   . If a task calls xTaskNotifyWait(), then it waits with an optional timeout until it receives a notification from some other task or interrupt 
     handler.

   __Prototype__
   BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotification Value, TickType_t xTicksToWait);

   __Parameters__
   ulBitsToClearOnEntry : Any bits set in ulBitsToClearOnEntry will be cleared in the calling RTOS task's notification value on entry to the 
      xTaskNotifyWait() function (before the task waits for a new notification) provided a notification is not already pending when xTaskNotifyWait() 
	  is called. For example, if ulBitsToClearOnEntry is 0x01, then bit 0 of the task's notification value will be cleared on entry to the function. 
	  Setting ulBitsToClearOnEntry to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value
	  to 0.
   ulBitsToClearOnExit : Any bits set in ulBitsToClearOnExit will be cleared in the calling RTOS task's notification value before xTaskNotifyWait() 
      function exits if a notification was received. The bits are cleared after the RTOS task's notification value has been saved in 
	  *pulNotificationValue (see the description of pulNotificationValue below). For example, if ulBitsToClearOnExit is 0x03, then bit 0 and bit 1
	  of the task's notification value will be cleared before the function exits. Setting ulBitsToClearonExit to 0xffffffff (ULONG_MAX) will clear
	  all the bits in the task's notification value, effectively clearing the value to 0.
   pulNotificationValue : Used to pass out the RTOS task's notification value. The value copied to *pulNotificationValue is the RTOS task's 
      notification value as it was before any bits were cleared due to the ulBitsToClearOnExit setting. If the notification value is not required, 
	  then set pulNotificationValue to NULL.
   xTicksToWait : The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when 
      xTaskNotifyWait() is called. The RTOS task does not consume any CPU time when it is in the Blocked state. The time specified in RTOS tick 
	  periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks.

   __Return Value__
	pdTRUE : if a notification was received, or a notification was already pending when xTaskNotifyWait() was called.
        pdFALSE : if the call to xTaskNotifyWait() timed out before a notification was received.

xTaskNotify()
   - xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification 
     value in one of the following ways:
      . Write a 32-bit number to the notification value
      . Add one (increment) the notification value
      . Set one or more bits in the notification value
      . Leave the notification value unchanged
   - This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead.

   __Prototype__
   BaseType_t xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction);

   __Parameters__
   xTaskToNotify : The handle of the RTOS task being notified. This is the Subject Task.
   ulValue : Used to update the notification value of the subject task. See the description of the eAction parameter below.
   eAction : An enumerated type that can take one of the values documented in the table below in order to perform the associated action.
             eNoAction, eIncrement, eSetValueWithOverwrite
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
FreeRTOS Licensing Model and API Interface

FreeRTOS is Free.
You can use it in your commercial applications without an issue.
No need to give any royalties to freeRTOS.
It's based on GNU GPL license and you should make open your code changes made to FreeRTOS kernel.
   GNU GPL says if you make any changes to the files of the owner, then you should make those changes open to the customer. So, if you make any 
   changes to the kernel source files provided by the FreeRTOS.org, you should make those changes open.
You do not need to open source your applications written using FreeRTOS API
   If you write a nice Robotic FreeRTOS application using FreeRTOS APIs which runs on FreeRTOS kernel, then you do not need to open source that 
   application.
Does it pass any safety standard?
   No it doesnt.
Is it safe to use FreeRTOS in Safety Critical Applications?
   No no no no no.
Does FreeRTOS.org provide any legal protection?
   No it does not.
Does FreeRTOS.org provide any technical support?
   No it does not.

FreeRTOS Commercial Licensing:
 . If you want: Legal Support, Technical support during your Product development, Ensure meeting safety standards, then you have to go for commercial 
   licensing of freeRTOS.org
 . SAFERTOS is a derivative version of FreeRTOS that has been analyzed, documented and tested to meet the stringent requirements of the IEC 61508 
   safety standard. This RTOS is audited to verify IEC 61508 SIL 3 conformance.
 . OpenRTOS is a commercially licensed version of FreeRTOS. The OpenRTOS license does not contain any references to the GPL.


Very important Links:
Download:
www.freertos.org

FreeRTOS Tutorial Books
http://shop.freertos.org/FreeRTOS_tutorial_books_and_reference_manuals_s/1825.htm

Creating a New FreeRTOS Project
http://www.freertos.org/Creating-a-new-FreeRTOS-project.html

FreeRTOS Quick Start Guide
http://www.freertos.org/FreeRTOS-quick-start-guide.html

Books and kits:
http://shop.freertos.org/RTOS_primer_books_and_manual_s/1819.htm
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
Overview of FreeRTOS Memory Management

RAM and Flash:
Every Microcontroller consists of two types of memories: RAM and Flash.
Usually RAM memory is smaller in size than FLASH memory.

RAM:
. Used to store your application data like global arrays, global variables, etc.
. You can download code to RAM and Run (e.g. patches).
. A part of RAM is used as STACK to store local variables, function arguments, return address, etc.
. A part of RAM is used as HEAP for dynamic memory allocations.

FLASH:
. Flash is used to hold your application code.
. Flash also holds constants like string initialization.
. Flash holds the vector table for interrupts and exceptions of the MCU.

Stack and Heap in embedded systems:
			    RAM		<---Push   Pop---->  (For Full Descending Stack)
___________________________________________________________
|		   |Heap		|	      Stack|
| ***		   |--->		|	       <---|
|__________________|____________________|__________________|
Low							  High

Before executing any instructions of the application, the startup code has to properly initialize the SP (stack pointer) to the starting address of 
the stack. SP (Stack pointer of MCU) is usually initialized to highest memory address of the RAM (beginning of Stack -- Full Descending Stack).

Heap is used for dynamic allocation of memory to application during runtime.
malloc()  just returns the memory pointer from Heap.

***The rest of RAM space is used for Global data, arrays, static variables, etc

Stack and Heap in embedded systems:

Stack memory is always accessed in FILO order (First in Last out). If you do out of order access of stack, then you may screw up your application.
Stack access is automatically tracked by SP register of your MCU.
Stack has order, so if you want to pop out 'b' in 'a''b''c''d' etc, you have to pop out 'a' first then pop 'b' next.
Heap can be accessed out of order/randomly because everything is accessed through a direct pointer to the individual data stored.

Stack

       |used|		|used|		|used|		sp: Stack Pointer
sp --->|____|		|____|		|____|		used: unavailable stack (already used)
       |    |		|args|		|args|		args: function arguments
       |    |		|____|		|____|		ret: return address
       |    |		|ret |		|ret |		locals: local variables
       |    |	 sp --->|____|		|____|		free: available stack
       |    |		|    |		|    |
       |    |		|    |		|locals
       |    |		|    |	 sp --->|____|
       |free|		|free|	 	|free|

//Registers loaded with args, R0 = a, R1 = b, R2 = c
//Return value gets overwritten into R0 when function returns
char do_sum(int a, int b, int c) {
	//local variables
	char x = 1;
	char y = 2;
	char *ptr;
	
	//some operations
	ptr = malloc(100);
	x = a + b + c;
	
	// exiting [R0 = x]
	return x;
}

//SP points to the last occupied item in the stack
// r0 = arg1, r1 = arg2, r2 = arg3, r3 = arg4; r0 = ret
// compiler will generate the push instructions into the stack to achieve this, before entering the function
// After returning, the stack will "unstack" and pop the contents and free up RAM. 


Heap:

How to manage the heap memory?
. Heap is a general term used for any memory that is allocated dynamically and randomly.
. Stack is managed by SP and instructions like PUSH/POP.
. How the heap is managed is really up to the runtime environment. C uses malloc & free and C++ uses new.

For embedded systems, malloc and free APIs are not suitable because they eat up large code space, lack of deterministic nature and fragmented 
overtime as blocks of memory are allocated.

FreeRTOS Stack and Heap Management:

Example: Temperature Monitoring Application
Task1: Sensor data gathering, Task2: Updating display, Task3: User input processing

When Task 1 is created, TCB-1 (Task Control Block) is created. So 3 tasks creates 3 TCBs.

Where do you think task's TCB and its associated stack will be created?

There are 2 options:
1) If you use dynamic creation method, then they will be created in the heap memory of the RAM.
2) If you create them statically, then they will be created in other part of the RAM except heap and stack space.

What decides the starting address and size of the heap.
By default, the FreeRTOS heap is declared by FreeRTOS kernel.
Setting configAPPLICATION_ALLOCATED_HEAP to 1 allows the heap to instead be declared by the application.

When you create a task dynamically, TCB and associated stack (TCB-n + Stack-n) will be created in the heap space of the RAM (xTaskCreate()).
Heap grows in direction of higher memory.
When xSemaphoreCreateBinary() is called, a Semaphore Control Block (SCB) will be similarly created in heap.
When xQueueCreate() is called, a Queue Control Block and Item List is created in heap(QCB + ItemList).

The other RAM space is used for global data, arrays, static variables, etc.

FreeRTOS Heap Management Schemes

heap_1.c (pvPortMalloc())
heap_2.c (pvPortMalloc() & vPortFree())
heap_3.c (pvPortMalloc() & vPortFree())
heap_4.c (pvPortMalloc() & vPortFree())
heap_5.c (pvPortMalloc() & vPortFree())
your_own_mem.c (pvPortMalloc() & vPortFree())

Application uses any one of these schemes according to its requirements

----------------------------------------------------------------------------------
FreeRTOS Task Deletion

Deleting a Task:
void vTaskDelete(xTaskHandle pxTaskToDelete);

Remember that when you use vTaskDelete() it wont deallocate the memory occupied by the task. It just marks the Task as deleted. Later when the idle 
task runs, it will de-allocate the memory for all the tasks which are marked as deleted.

You rarely have to delete a task, because they are typically constantly running/suspended/blocked in an RTOS application. But there are scenarios 
where it may be good to do.

Exercise: 005LED_Task_Notify
Task to task notification using direct notification APIs of FreeRTOS.
Create 4 tasks that toggle 4 LEDs of the STM32F446RE board.
Create a button Task that polls for the button press every 10ms.
If the button task detects button press, it should send a notification to LED toggling task.
When the LED toggling task receives the notification, it should delete itself.

Task-1: LED_Red_task: toggle_period: 1s Priority: 4
Task-2: LED_Yellow_task: toggle_period: 800ms Priority: 3
Task-3: LED_Blue_task: toggle_period: 600ms Priority: 2
Task-4: LED_Green_task: toggle_period: 400ms Priority: 1
Task-5: Button_task: sense_period: 10ms Priority: 5

Scenario: Shared Data Access:
1. 1st Button press, button task ends notification
2. Task-1 gets notification
3. Task-1 suspends scheduler
4. Task-1 fails to modify the global variable 'next_task_handle'
5. Task-1 resumes scheduler
6. 2nd button press, button task sends notification newly updated 'next_task_handle'

vTaskSuspendAll(void);  //task.h
//suspends the scheduler. prevents context switch from occurring but leaves interrupts enabled. If an interrupt requests a context switch while the 
scheduler is suspended, 
//then the request is held pending and is performed only when the scheduler is resumed (unsuspended)

BaseType_t xTaskResumeAll(void);
//Resumes the scheduler after it was suspended using a call to vTaskSuspendAll();
//xTaskResumeAll() only resumes the scheduler. It does not unsuspend tasks that were previously suspended by a call to vTaskSuspend();


void vTaskSuspend( TaskHandle_t xTaskToSuspend );
void vTaskResume( TaskHandle_t xTaskToResume );

Note: Used task deletions at first (after button presses cycled through deleting each task individually)
      Then used task suspensions instead and resumed all tasks and started over if button was pressed after all were suspended
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
ARM Cortex M Interrupt Priority and FreeRTOS Task Priority

FreeRTOS Task Priority vs Hardware Priority (Processor Interrupt/Exception Priority):
. Hardware priority is the priority values assigned to various interrupts and system exceptions of the processor (peripherals external to processor: 
  ADC, Timer, Eth, UART, SPI, I2C, GPIO etc + 15 Exceptions)

User tasks run in thread mode of the processor (process context)
Interrupt handlers run in handler mode of the processor (interrupt context)

Priorities:
FreeRTOS Task Priorities: Lower the priority value, the lower the priority (task urgency) (0 lowest)
ARM Cortex Mx Interrupt Priorities: Lower the priority value, the higher the priority (interrupt urgency) (0 highest)


FreeRTOS Hardware Interrupt Configuration Items:
configKERNEL_INTERRUPT_PRIORITY
	-Decides the priority level for the kernel interrupts (Systick Interrupt, PendSV system exception, SVC exception)
	What is the lowest and highest interrupt priority values possible in an MCU with ARM Cortex Mx processor?
	.
	What is the value of __NVIC_PRIO_BITS macro?
	. 4U (4 bits, 16 priority levels highest_0x00,0x10,0x20,.., 0xf0_lowest)
configMAX_SYSCALL_INTERRUPT_PRIORITY
	-In the newer version of FreeRTOS port.c file, its name is changed to configMAX_API_CALL_INTERRUPT_PRIORITY
	   This is a threshold priority limit for those interrupts which use freeRTOS APIs which end with "FromISR"
	   Interrupts which use freeRTOS APIs ending with "FromISR" should not use priority greater than this value. (Greater priority = less in numeric 
	   value)

Interrupts that do not call API functions can execute at priorities above configMAX_SYSCALL_INTERRUPT_PRIORITY and therefore never be delayed by the 
RTOS kernel execution
configMAX_SYSCALL_INTERRUPT_PRIORITY = 4; configKERNEL_INTERRUPT_PRIORITY = 0;

Priority[0:7]
  . Interrupts that do not call any FreeRTOS.org API functions can use all interrupts prioirities and will nest (0-7)
  . ISR's that call API functions ending in "FromISR" can use these interrupt priorities, and will nest (0-4)
  . Interrupts running at these priorities will never be delayed from executing because of anything the FreeRTOS.org kernel is doing. (5-7)

The interrupt service routine that uses an RTOS API function must have its priority manually set to a value that is numerically equal to or greater 
than configMAX_SYSCALL_INTERRUPT_PRIORITY.
Remember that in ARM, greater priority value means lesser urgency.

Available Priority Values of ISR's based on configMAX_SYSCALL_INTERRUPT_PRIORITY = 0x50 :
ISRs which do not call FreeRTOS API ending in "FromISR" : (highest prio) 0x00, 0x10, 0x20, 0x30, 0x40
ISRS which call FreeRTOS API ending in "FromISR" : 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0 (lowest prio)

In Conclusion:
FreeRTOS APIs that end in "FromISR" are interrupt safe, but even these APIs should not be called from ISRs that have priority (urgency) above the 
priority defined by configMAX_SYSCALL_INTERRUPT_PRIORITY.
Therefore, any interrupt service routine that uses an RTOS API function must have its priority value manually set to a value that is numerically 
equal to or greater than configMAX_SYSCALL_INTERRUPT_PRIORITY setting.
Cortex-M interrupts default to having a priority value of zero. Zero is the highest possible priority value. Therefore, never leave the priority of 
an interrupt that uses the interrupt safe RTOS API at its default value.
There are 2 configuration items:
  configKERNEL_INTERRUPT_PRIORITY (0xF0)
	The kernel interrupt priority config item actually decides the priority level for the kernel related interrupts like systick, pendsv and svc, 
	and it is set to lowest interrupt priority possible.
  configMAX_SYSCALL_INTERRUPT_PRIORITY (0x50)
	The max syscall interrupt priority config item actually decides the maximum priority level, that is allowed to use for those interrupts which
	use FreeRTOS APIs ending with "FromISR" in their interrupt service routines.

----------------------------------------------------------------------------------
Exercise: 006LED_btn_isr
. ISR to task notification using direct notification APIs of freeRTOS
. Create 3 tasks that toggle 4 different LEDs with the STM32F446RE
. When user presses the button, the button interrupt handler must run, and it should send notification to the current LED toggling task.
. When LED toggling task receives the notification, it should delete itself.

							       			xTaskNotify() X / xTaskNotifyFromISR()**		xTaskNotifyWait()
[Button Press] -- (Hardware Interrupt) -- > [Interrupt context / Button interrupt handler] ---- (Notify) ---- > [Process context / LED toggling task]

FreeRTOS "FromISR" APIs
. FreeRTOS provides separate APIs for use from interrupt handlers. These APIs end with "FromISR"
. If a FreeRTOS API doesn't end with "FromISR" then it should not be used in interrupt context (Inside of an ISR)

Since configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY == 5, the EXTI line[15:10] interrupts setting in STM32Cube Mx NVIC settings needs to be set to 
5 or higher (I chose 6). The User Button (PC13) would be using EXTI line 13 for interrupts.
	(Higher the priority, the lower the urgency)

portDISABLE_INTERRUPTS() disables all the interrupts with priority values 0x50 to 0xF0 (5 to 15) (above threshold) because 
configMAX_SYSCALL_INTERRUPT_PRIORITY = 0x50; Interrupts with priority lower than 0x50 will still be allowed.

----------------------------------------------------------------------------------
Exercise: 007
Write an application that creates 2 Tasks
Task-1 with priority 2; Task-2 with priority 3
Task-1 is a continuous task and should toggle the red LED with 100ms duration between ON and OFF.
Task-2 is a continuous task and should toggle the green LED with 1 second duration between ON and OFF.
When the user button is pressed, the priority of both the tasks should be exchanged.
i.e. Task-1's priority must be reconfigured for Task-2's priority and vise-versa.

void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority);
INCLUDE_vTaskPrioritySet must be 1 in FreeRTOSConfig.h
Set the priority of any task.
A context switch will occur before the function returns if the priority being set is higher than the currently executing task.

UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask);
INCLUDE_uxTaskPriorityGet must be 1 in FreeRTOSConfig.h
Obtain the priority of any task.


 Q. Lets say in freeRTOS , Task1( priority )= 5 is currently executing on the CPU, if Task2(priority)= 6 unblocks due to some 
    reason, will context switch take place to task 2 immediately or task 2 should wait until the next tick interrupt ?
 A. No, Task 2 will preempt the Task-1 immediately.
 >  Yes, in FreeRTOS whoever unblocks the blocked task should also check whether the unblocked task has got 
    the higher priority than the currently running task. If true, then task yield function has to be called 
    to make sure that, the newly unblocked higher priority task immediately takes over the CPU.

Tasks -> Thread mode
Interrupts/Exceptions -> Handler mode
Handler mode will always be higher priority than Thread mode.

Q. If 6 bits are implemented in the priority register of the MCU, then how many interrupts levels are available ?
What is the highest priority level  and lowest priority level ?
A. 64, 0x00, 0xFC

Q. Does having more priority levels affect RAM usage of the MCU ?
A. Yes ! Lets say in a MCU there are 8 priority levels from 0 to 7, that means at the worst case 8 interrupts can 
   nest isnt it ? That means at the worst case 7 stack frames are moved to the stack memory . So, 
   7 * sizeof(each stack frame) number of bytes will be consumed. So, more nesting means more stack consumption.
----------------------------------------------------------------------------------
Interrupt Safe APIs:

FreeRTOS "FromISR" APIs
. These APIs are also called interrupt safe APIs
. These are meant to be used from an interrupt handler

Why are there separate "FromISR" APIs?
1. It makes APIs implementation simpler :
   When called from task context, many RTOS APIs can put the calling task to a blocked state, but the same cannot happen when called from 
   interrupt handlers because you cannot put the interrupt handler or interrupt context code to blocked staate. The blocked state is for tasks, 
   not for interrupt handlers. So, now the API must determine from which context it was being called, interrupt or task context, and decide 
   accordingly. This approach increases code overhead, and some architecture doesn't support determining the context. To overcome this problem, 
   freeRTOS gives separate APIs to be called from interrupt handlers and prohibits using APIs which doesn't end with "FromISR" inside an interrupt 
   handler.

2. Some API function parameters would become redundant and confusing

Disadvantage of using separate APIs
1. Application writer must redesign the logic when there is a need to call a third-party function from an interrupt handler that uses FreeRTOS API 
that doesn't end with 'FromISR'

**Can't do this, because you're calling xQueueSend (non-'FromISR' FreeRTOS API) from an interrupt handler**
						//Third party function
void adc_interrupt_handler(void) {		void apply_filtering(int16_t data) {
	sensor_data = adc_read_data();			xQueueSend(filter_queue, data)
	apply_filtering(sensor_data);   ------> }    
}									^
									|
**Instead, do this:**							|
							//Task Handler  |
void adc_interrupt_handler(void) {			void adc_task_handler(void *p) {
	sensor_data = adc_read_data();				while(1) {
	xQueueSendFromISR(adc_queue, sensor_data);			xQueueReceive(adc_queue, &sensor_data, wait_time);
}									apply_filtering(sensor_data);
								}
							}
//When ISR exits, adc_task_handler runs and calls third party code as if it was done in interrupt handler.
----------------------------------------------------------------------------------
FreeRTOS Hook Functions

FreeRTOS Hook functions:
. Idle Task hook function
. RTOS Tick hook function
. Dynamic memory allocation failed hook function (Malloc Failed Hook Function)
. Stack overflow hook function
These hook functions you can implement in your application code if required.
The FreeRTOS kernel will call these hook functions whenever corresponding events happen.

Idle Task Hook Function:
. Idle task hook function implements a callback from idle task to your application.
. You have to enable the idle task hook function feature by setting this config item configUSE_IDLE_HOOK to 1 within FreeRTOSConfig.h
. Then implement void vApplicationIdleHook(void); in your application.
. That's it, whenever idle task is allowed to run, your hook function will get called, where you can do useful stuff like sending the MCU to 
  low power mode.
void vApplicationIdleHook(void) {} //main.c

RTOS Tick Hook Function:
. configUSE_TICK_HOOK should be 1 in FreeRTOSConfig.h
void vApplicationTickHook(void) {} //main.c

Malloc Failed Hook Function:
. configUSE_MALLOC_FAILED_HOOK should be 1 in FreeRTOSConfig.h
void vApplicationMallocFailedHook(void) {} //main.c
//triggers if there is insufficient heap memory in RAM to call malloc()

Stack Overflow Hook Function:
. configCHECK_FOR_STACK_OVERFLOW should be 1 in FreeRTOSConfig.h
void vApplciationStackOverflowHook(TaskHandle_t xTask, signed char *pcTaskName) {} //main.c
//triggers whenever there is a task that consumes more than the allowed stack memory

**Enabling sleep mode during idle task hook for 003LED_Block_tasks**
Table 23. Low-power mode summary (Power modes of a MCU are discussed in MCU2 course)

Putting in sleep mode with WFI entry (wait for interrupt)
WFI makes the processor suspend execution (clock is stopped) until one of the following events takes place: IRQ interrupt, FIQ interrupt, Debug 
entry request made to processor.

This Idle Task Hook function changed the current consumption of the project from 50ma to 18-20ma by utilizing sleep mode for the processor during 
downtime.

Default priority of idle task is 0, and will only run if all other tasks are blocked.
If Task 1's priority is 0, and idle task's Priority is also 0, then will both run alternately ? Yes, they will alternate time slices due to equal 
priority. The job of the idle task is to cleanup memory of those kernel objects which got deleted, and to keep the processor busy when there are 
no tasks to run on the CPU.
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
Free RTOS Queue Management

Queues and its features:
. A queue is a data structure which can hold a finite number of fixed size data items.
  . It has a head (item-0) and a tail (item-n).
  . To Enqueue (write) is to place an item at the tail, while Dequeue (read) takes off an item from the head. (Data is written to end of queue and 
    read from the front)
  . The maximum items a queue can hold is its length. Total Size = (n_items * sizeof(item))
  . FIFO access

If queue is empty, both the tail and head pointers will point to the same location (head of queue).
If queue has 1 item, then it is simultaneously both at the front and back of the queue (tail points to location 1 item behind head now)
Tail points to location before last item in queue.

Creating a Queue using FreeRTOS API:

This handle is then used to do 			
lots of queue operations like writing, 		number of items queue 		  size of single 
reading, seeking, deleting, etc			should hold (length)		  item in bytes
  v							  v				  v
xQueueHandle xQueueCreate(unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize)
  ^
if the creation is successful, the
API returns the reference (a pointer)
to the created queue, otherwise NULL


struct AMessage {
	char ucMessageID;
	char ucData[20];
};

void vATask(void *pvParameters) {
	QueueHandle_t xQueue1, xQueue2;

	/* Create a queue capable of containing 10 unsigned long values
	xQueue1 = xQueueCreate(10, sizeof(unsigned long));
	
	if(xQueue1 == NULL) {
		/* Queue was not created and must not be used */
		//Insufficient memory in heap
	}
	
	/* Create a queue capable of containing 10 pointers to AMessage structures. These are to be queued by pointers as they are relatively large 
	structures */
	xQueue2 = xQueueCreate(10, sizeof(struct AMessage *));
	//structure would be too large to pass on its own ( (21 * 10) = 210 Bytes!).
	//instead pass pointers to the structures (10*4 = 40Bytes)

	if(xQueue2 == NULL) {
		/* Queue was not created and must not be used */
		//Insufficient memory in heap
	}
	
	/* Rest of Task Code */
}
Total_Size_Queue1 = QCB + (10 * 4)Bytes

Sending Data to the Queue:
//send data to the front (head) of the queue
portBASE_TYPE xQueueSendToFront(xQueueHandle xQueue, const void* pvItemToQueue, portTickType xTicksToWait); 
//send data to the back (tail) of the queue
portBASE_TYPE xQueueSendToBack(xQueueHandle xQueue, const void* pvItemToQueue, portTickType xTicksToWait); 
  xQueue: Handle of created queue
  pvItemToQueue: the address to the data item which you want to send to the queue
  xTicksToWait: number of ticks the task who calls this api must wait for if the queue is full (or port_MAX_DELAY)

Receiving Data from the Queue:

portBASE_TYPE xQueueReceive(xQueueHandle xQueue, const void* pvBuffer, portTickType xTicksToWait); //read (and remove) data from the queue
portBASE_TYPE xQueuePeek(xQueueHandle xQueue, const void* pvBuffer, portTickType xTicksToWait); //read (but dont remove) data from the queue
  xQueue: Handle of created queue
  pvBuffer: the address for holding the data item read from queue
  xTicksToWait: number of ticks the task who calls this api must wait for if the queue is full (or port_MAX_DELAY)
----------------------------------------------------------------------------------
Exercise 008: Queues and Timers

Write a FreeRTOS application that takes input(commands) from the user over UART and handles LED and real-time clock (RTC) peripheral of the MCU.
1)Processing user sent commands over UART
2)FreeRTOS queue handling
3)FreeRTOS software timers

Menu Task
	=========================
	|	  Menu		|
	=========================	
	LED effect 	---> 0
	Date and Time 	---> 1
	Exit 		---> 2
	Enter your choice here : 
LED Task
	=========================
	|	LED Effect	|
	=========================
	(none,e1,e2,e3,e4)
	Enter your choice here :
RTC Task
	=========================
	|	   RTC		|
	=========================
	Current Time&Date:	00:02:22 [AM] 	01-01-2000
	Configure Time		----> 0
	Configure Data		----> 1
	Enable reporting	----> 2
	Exit			    ----> 4
	Enter your choice here : 

[Menu Task] ---->  [Menu] ---Enqueue--> [Print Queue] ---Dequeue--> [Print Task] ----> [UART] ---> To user


From user ---> [UART] ---> [UART ISR]  ---Enqueue---> [Input data Queue] ---Dequeue---> [Command handling Task] ---> [Format the data into command] 
								|															     ^                      |
								|________________________Notification____________________________|						---> [Notify relevant tasks]


In main, create 5 tasks of same priority and 2 queues.
Create main.c, task_handler.c, led_effect.c, rtc.c

Receiving data from user:
. Enable UART data reception (byte by byte) in IT mode.
. Implement UART receive complete callback in main.c
	. store the data byte into input data queue
	. when '\n' is detected, notify the command handling task


/* This function called from UART interrupt handler, hence executes in interrupt context */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {

	if(/* TODO: check : is queue full ? */) {
		/* Queue is not full */
		
		/* TODO: Enqueue data byte */
	} else { 
		/* Queue is full */

		if(/* TODO: check, is user_data '\n'? */) {
			/* user_data = '\n' */
			/* TODO: make sure that last data byte of the queue is '\n' */
		}
	}
	/* TODO: send notification to command handling task if user_data = '\n' */
	/* TODO: Enable UART data byte reception again in IT mode */
}

Implementing Menu Task:
Entry: 		
	Print the menu
	Notify wait for command notification
On Receive:	
	Extract the command
	Update the state variable
	Notify the next task
Exit:
	Blocks by calling notify wait

Implementing LED Task:
Entry: 		
	Print the menu
	Notify wait for command notification
On Receive:	
	Take action as per the command received
	Update the state variable
Exit:
	Always notify menu task
	Blocks by calling notify wait

void led_task(void *param) {
	uint32_t cmd_addr;
	command_t *cmd;
	const char* msg_led = 	"========================\n"
							"|	LED Effect	|\n"
							"========================\n"
							"(none,e1,e2,e3,e4)	 \n"
							"Enter your choice here: \n"
	while(1) {
		/* TODO: Wait for notification (Notify wait)a */
		/* TODO: Print LED menu */
		/* TODO: Wait for LED commands (Notify wait) */
		if(cmd->len <= 4) {
			if(!strcmp((char*)cmd->payload, "none")) 
				led_effect_stop();
			else if(!strcmp((char*)cmd->payload, "e1"))
				led_effect(1);
			else if(!strcmp((char*)cmd->payload, "e2"))
				led_effect(2);
			else if(!strcmp((char*)cmd->payload, "e3"))
				led_effect(3);
			else if(!strcmp((char*)cmd->payload, "e4"))
				led_effect(4);
			else
				/* TODO: Invalid Message */
		} else
			/* TODO: Invalid Message */

		/* TODO: Update state variable */
		curr_state = sMainMenu;

		/* TODO: Notify menu task */
		xTaskNotify(handle_menu_task, 0, eNoAction);
	}
}

LED1 = LED_RED, LED2 = LED_YELLOW
LED3 = LED_BLUE, LED4 = LED_GREEN

LED Effects (500ms delay) : (1,2,3,4) == (RED,YELLOW,BLUE,GREEN)

e1 LED_effect_1:    (ON,ON,ON,ON) -> (OFF,OFF,OFF,OFF) [repeat]
e2 LED_effect_2:  (OFF,ON,OFF,ON) -> (ON,OFF,ON,OFF)   [repeat]
e3 LED_effect_3: (ON,OFF,OFF,OFF) -> (OFF,ON,OFF,OFF) -> (OFF,OFF,ON,OFF) -> (OFF,OFF,OFF,ON) [repeat]
e4 LED_effect_4: (OFF,OFF,OFF,ON) -> (OFF,OFF,ON,OFF) -> (OFF,ON,OFF,OFF) -> (ON,OFF,OFF,OFF) [repeat]

----------------------------------------------------------------------------------
FreeRTOS Software Timers

Use case of Software Timers:
Toggle the LED periodically (e.g. every 500ms) with LED_Toggle()

Hardware Timers vs Software Timers

Hardware Timers:
	Handled by the Timer peripheral of MCU
	No FreeRTOS Apis. You have to create your own function to manage the timer peripherals.
	Micros/nano seconds resolutions are possible
Software Timers:
	Handled by FreeRTOS kernel Code
	FreeRTOS APIs are available
	Resolution depends on RTOS_TICK_RATE_HZ

Software Timers APIs:
https://www.freertos.org/FreeRTOS-Software-Timer-API-Functions.html

xTimerCreate()
xTimerCreateStatic()
xTimerIsTimerActive()
pvTimerGetTimerID()
pvTimerGetName()
xTimerStart()
xTimerStop()
xTimerChangePeriod()
xTimerDelete()
xTimerReset()
xTimerStartFromISR()
xTimerStopFromISR()
xTimerChangePeriodFromISR()
xTimerResetFromISR()
pvTimerGetTimerID()
vTimerSetTimerID()
xTimerGetTimerDaemonTaskHandle()
xTimerPendFunctionCall()
xTimerPendFunctionCallFromISR()
pcTimerGetName()

FreeRTOS software timers utilize a queue called "timer queue". Using any of the timer APIs will post a message to that timer queue
----------------------------------------------------------------------------------
008Queues_and_Timers continued

Now we have to create 4 FreeRTOS software timers (one for each LED) to implement the different LED toggling effects separated by 500ms.

RTC Task:
Configuring date and time info
Reading date and time info

// https://www.educative.io/edpresso/resolving-the-a-label-can-only-be-part-of-a-statement-error 
//Resolving the "a label can only be part of a statement and a declaration is not a statement" error
//The a label can only be part of a statement and a declaration is not a statement error occurs in C when it encounters a declaration 
//immediately after a label.
//
//The C language standard only allows statements to follow a label. The language does not group declarations in the same category as statements.
//The error can also occur when using switch statements in C, as the language treats cases similar to labels. Consider the following error scenario:
//The solution is the same as before; a semi-colon needs to be added after the case 'a' statement on line 77. Alternatively, the entire case can be 
//enclosed in curly braces to circumvent the error. 
//The following code snippet implements both ways of fixing this error:


Q. Let's say a queue is full, and a task1 of priority 5 was blocked on a queue while its attempt to write on that queue, now lets say task2 of 
   priority 3 removes a data item from that queue. 
Do you think the moment task 2 removes a data item, it will be preempted by task 1 ?

A. Yes, Task 2 will be preempted by Task-1 the moment it removes the data item from the queue.

And also remember that ISRs can not block on the queue if the queue is empty or full.

Q. Can queue APIs which end with "FromISR" are allowed to do task yielding ?
A. No (thread vs handler mode)

Q. Can a task block on queue indefinitely ?
A. Yes if you use portMAX_DELAY, then task will block indefinitely !

Q. Can a task choose not to block on a queue ?
A. Yes use 0 , in the delay parameter of the queue read/write APIs

xQueueCreate( 5, sizeof(uint32_t) )
Assume : 32bit Processor
20bytes + sizeof(QCB) will be consumed in the heap space of the RAM.

Q. Can we use Queue for synchronization between tasks or between task and an interrupt ?
A. Yes
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
Semaphore for Synchronization, Mutual Exclusion and Interrupt Management

Synchronization and Mutual Exclusion in the Real World

A semaphore is a kernel object or you can say kernel service, that one or more threads of execution can acquire or release for the purpose of 
synchronization or mutual exclusion. Before understanding semaphores, lets first explore what synchronization and mutual exclusion are.

Synchronization in the real world:
Meeting @ 11am between Manager and Employee.
The activity of going to a meeting is aligned with the reference point or time of 11AM.
The meeting is synchronized with perfect timing.

If a meeting is just scheduled for "tomorrow":
then the meeting timings are not defined between manager and you, and is not aligned with time. In other words, theres no synchronization.
You can be early, wasting your time by arriving sooner; or late, wasting managers time by arriving late.

Synchronization with Computing:

Task-A Producer     						Task-B Consumer   (equal priorities)
t1: Task A runs first and is waiting for data from 		t2: Task B runs which means Task A is pre-empted. 
    Device driver.						(no useful action taken)					
t3: Task A runs again and finds the device driver not 		t4: no data is available, so it again doesnt take any action
    yet given any data.						(Here Task B unnecessarily takes over the CPU to check whether data is produced or not)

Solution: Let Task A signal Task B whenever the data is available.

Implementing the signalling:
Kernel Objects which can be used for Synchronization:
Events (or event flags)
Semaphores (counting and binary)
Queues and Message Queues
Pipes
Mailboxes
Signals (UNIX like signals)
Mutex

FreeRTOS supports Semaphores, Queues, and Mutexes.

Mutual Exclusion:

Task 1: (owns)
Shared Entity (Global variable, data structure, common function which use some global data, peripheral memory, etc)

Task 2 cannot access the shared entity unless Task-1 withdraws the ownership.

Access of a Shared Entity/Resource is referred to as a Critical Section.
Both Mutex and semaphore services can be used to implement the mutual exclusion.
Using mutex to implement the mutual exclusion is more beneficial than using a semaphore.

Synchronization means to align a number of Tasks to achieve a desired behavior.
Whereas, Mutual Exclusion is avoiding a task to execute the critical section which is already owned by another task for execution.
Typically, Semaphores are used to implement the synchronization between tasks and interrupts.
Mutexes are the best choice to implement mutual exclusion. That means protecting access of a shared item.
Semaphores can also be used to implement mutual exclusion but it will introduce some serious design issues.

Creating a Semaphore:
Semaphores are kernel objects, or you can say kernel services which you can use to achieve the synchronization and mutual exclusion in your project.

When a semaphore is created, the kernel assigns an associated Semaphore Control Block (SCB) that contains Semaphore ID or Name, Value (binary or a 
count -- how many semaphore tokens are available) and a Task-Waiting-List. Semaphores are basically "keys" or "tokens" that tasks can acquire in 
order to carry out the intended operation.

A single semaphore can be acquired only a finite number of times by various tasks depending upon how the semaphore is initialized.
If value = 4, then 4 semaphore keys are currently available. If a task attempts to acquire the key for the 5th time, it will be blocked and moved 
to the task waiting list. The value decrements when a key is acquired, and increments when its given back.

The kernel can provide two types of semaphores, Binary Semaphores and Counting Semaphores.

Binary Semaphore:
As the name indicates, this semaphore works on only two values: 1 and 0
If the value is 1, the key is available. And when value is 0, key is unavailable.
1. Synchronization
	Synchronization between tasks or sync between interrupts and tasks.
2. Mutual Exclusion
	Binary Semaphore can also be used for Mutual Exclusion, that is to guard the critical section.

Counting Semaphore:
The Value can be any number, 5 would mean there are 5 keys.
Task waiting list will have the Blocked tasks which are waiting for keys.


Use Case:


Event/Interrupt counting and handling:
. Each time an event/interrupt occurs, the event/interrupt handler will "give" the semaphore, 
  thus incrementing the semaphore count value. Essentially the events/interrupts are being logged.
void interrupt_handler(void) {
	do_important_work();	//Very short code
	sema_give(&sem);	//Give means release the key
}

. This is a handler task, which gets unblocked when the semaphore is available and 
  handles all the events or interrupts that are logged by "taking" the semaphore.
void task_function(void) {
	//if taking a key is unsuccesssful, then this task will be blocked until a key is available.
	while(sem_get(&sem)) { //Get means attempting to take the key
		//only if key acquire is successful, code will go here
		//Do time consuming work of the ISR
	}
}

Resource Management:
In this usage scenario, the count value indicates the number of resources available. To obtain 
control of a resource, a task must first obtain a semaphore by decrementing the semaphore's count value.
When the count value reaches zero, there are no free resources. When a task finishes with the resource it
'gives' the semaphore back, thus incrementing the semaphores count value.

Binary Semaphore to achieve Synchronization between two tasks:
The main use of a binary or counting semaphore is synchronization between tasks or tasks + interrupts.

Example (Sync 2 Tasks):

Task-1 Data Producer   ---->  Sema_key  ----> Task-2 Data Consumer
		  Increments key	Unblocks Task-B
		  when data is 		if it was blocked due to
		  produced		non-availability of key

Once task-2 unblocks, then it will test the sema_key. If it is available, then it will consume the data.

void task1_running(void) {
	if(TRUE == produce_some_data()) {
		//This is a signal for task-2 to wake up if it is blocked due to non-availability of key
		sema_give(&sema_key); //'GIVE' operation will increment the semaphore value by 1.
	}
}

void task2_running(void) { // Lets assume Task-2 runs first
	//If sema_key is unavailable, then task-2 will be blocked
	//If sema_key is available, then task2 will take it and sema_key becomes unavailable again
	while(sema_take(&sema_key)) {
		//Task will come here only when the sem_take operation is successful.
		//Let's consume the data
		//Since the sem_key is zero at this point, the next time when Task-2 tries to take, it will be blocked.
	}
}

Exercise:
Create 2 Tasks:  1) Manager task  2) Employee task
With manager task being higher priority.
When manager task runs, it should create a "Ticket ID" and post it to the queue and signal the employee task to process the "Ticket ID"
When employee task runs, it should read from the queue and process the "Ticket ID" posted by the manager task.
Use binary semaphore to synchronize between manager and employee task.

When using binary semaphores, you have to first create with vSemaphoreCreateBinary(). Since it is created in its empty state, you have to first 
use xSemaphoreGive() to set the key value to 1 before using subsequent xSemaphoreGive() or xSemaphoreTake() APIs.



Synchronization between Interrupt and Task:
The Binary Semaphore is very handy and well suited to achieve synchronization between an interrupt handler execution and the task handler execution.

void interrupt_handler(void) {
	do_important_work(); //Very short code
	xSemaphoreGiveFromISR(&sem); //Give means release the key
} //Exit from interrupt

//Helper task for the interrupt which does the time consuming work on behalf of the interrupt handler.
void helper_task(void) {
	//If taking a key is unsuccessful, then this task will be blocked until key is available
	while(xSemaphoreTaks(&sem)) { //Get means, trying to take the key
		//If taking key was successfull..
		//Do time consuming work of the ISR
	}
}

The interrupt handler signals its helper task by using a binary semaphore ( xSemaphoreGiveFromISR(&sem) )
Once the interrupt handler gives the semaphore back, the helper task will get unblocked and execute from the moment where it was last blocked.

1. Task is initially in blocked state.
2. Interrupt occurs (which gives the semaphore making it "available")
3. Task unblocked and tries to take the semaphore
4. Task took the semaphore (making the semaphore "unavailable")
In the helper task, the Task continuously tries to take the semaphore which is unavailable until the interrupt handler signals with 
   xSemaphoreGiveFromISR to unblock the Task.


Events Latching
A binary semaphore can only have a 'count of 1' so the maximum amount of events it can latch is also 1.
If there are many interrupts coming at high frequency, then you cannot latch more than 1 event with a binary semaphore, hence why counting 
semaphores are used.
1. When the interrupts/events happen relatively slow, the binary semaphore can latch at most only one event.
2. If multiple interrupts/events trigger back to back, then the binary semaphore will not be able to latch all the events. So some events 
   will be lost.
3. How do you solve this issue? "Counting Semaphores"


Counting Semaphore to latch and process multiple events:
Semaphore count is initialized to 0, and count is maximum 5.
count = 0 means the Semaphore not available, which puts the Task in the blocked state waiting for semaphore.
An interrupt occurs, which gives the semaphore to the task, unblocking it.
When the task is unblocked, it tries to take the semaphore which is now available.
When the task successfully takes the semaphore, the semaphore becomes unavailable once more.

Now, another 2 interrupts occur while the task is still processing the first event. The ISR 'Gives' the semaphore each time -- effectively 
latching both events so neither event is lost. When processing of the first event completes, the task calls xSemaphoreTake() again. Again, 
two semaphores are already 'available', one is taken without the task ever entering the Blocked State, leaving one more 'latched' semaphore available.


Exercise: 010Counting_Semaphore_Tasks
Create 2 tasks:
1) Handler Task
2) Periodic Task
Periodic task priority must be higher than the handler task
Use counting semaphore to process latched events (by handler task) sent by fast triggering interrupts
Use the counting semaphore to latch events from the interrupts


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
Mutual Exclusion using Binary Semaphores

Access to a resource that is shared either between tasks or between tasks and interrupts needs to be serialized using some techniques to ensure 
data consistency.
Usually a common code block which deals with a global array, variable, or memory address, has the possibility to get corrupted, when many tasks 
or interrupts are racing around it.

#define UART_DR  *((unsigned long *) (0x40000000)
/* This is a common function to write to UART DR */
int UART_Write(uint32_t len, uint8_t *buffer) {
	for(uint32_t i = 0; i < len; i++) {
		sema_take_key(bin_sema);  //get_lock(); 	//key value becomes 0
		while(!is_DR_empty());
		UART_DR = buffer[i]
		sema_give_key(bin_sema);  //release_lock(); 	//key value becomes 1
	}
}

//bin_sema = 1 (available)

There are two ways to implement mutual exclusion in FreeRTOS:
1) Using Binary semaphore APIs
2) Using Mutex APIs

We have already explored about binary semaphores being used for synchronization, but the same binary semaphore can be used to avoid the race 
condition, or in other words, achieve mutual exclusion.

If a task tries to take a key when the semaphore is unavailable (bin_sema == 0) then it will be blocked and put in a waiting list.
The moment (bin_sema == 1) after sema_give_key() is called, the task will be unblocked and continue where it left off.


******* The main issue with using a binary semaphore for mutual exclusion is that it gives a chance for priority inversion to occur! A higher 
priority task can be blocked due to non-availability of the semaphore and will be waiting on the lower priority task to release the semaphore. 
It is unwise and bad design to have a higher priority task to be dependent on a lower priority task. Additionally, if there is a "medium priority" 
task that appears and occupies the processor, unallowing the lower priority task to run, then the lower priority task would be delayed indefinitely 
while leaving the highest priority task blocked forever. This is exactly the scenario of priority inversion. As an application contains more tasks 
with varying priority levels, it needs to be tested against priority inversion. What is the best way to solve this issue? Use MUTEXes instead of
binary semaphores for mutual exclusion dealing with many different priority levels. MUTEX has built-in intelligence to minimize the priority 
inversion effect. A MUTEX is another kernel service or object that is carefully designed to take care of this priority inversion problem.
*******
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
Advantages of Mutex over Binary Semaphore:

Priority Inheritance
	- Mutexes and binary semaphores are very similar -- the only major difference is mutexes automatically provide a basic 'priority inheritance' 
	  mechanism.
	- Priority inheritance is a technique by which a mutex minimizes the negative effects of priority inversion. A mutex is not able to fix the 
	  priority inversion problem completely,
	  but it lessens its impact.
	- Most of the RTOS including FreeRTOS mutex implementation implements priority inheritance feature.
	- Since mutex has all these features to avoid priority inversion, the memory consumed by mutex service may be higher than the binary semaphore..

Scenario with LP, MP, and HP tasks:
1. The LP task takes a mutex before being preempted by the HP task.
2. The HP task attempts to take the Mutex but can't because it is still being held by the LP task. The HP task enters the blocked state to wait for 
   the semaphore to become available.
3. The LP task is preventing the HP task from executing so it inherits the priority of the HP task. The LP task now cannot be preempted by the MP 
   task, so the amount of time that 
   priority inversion exists is minimized. When the LP task gives the mutex back, it returns its original priority!
4. The LP task returning the mutex causes the HP task to exit the blocked state as the mutex holder. When the HP task has finished with the mutex 
   it gives it back. The MP task only 
   executes when the HP task returns to the blocked state so the MP task never holds up the HP task.

Code Exercise - 16: Mutex Example:
2 Tasks are created with diff priorities.
Both tasks will print some characters to the STDOUT/UART when they get a chance to run.
Task 2 prio > Task 1 prio
Task 2 runs first and prints some data to the STDOUT then it blocks for a "random" number of ticks.
When Task2 blocks, Task1 takes over the CPU and start running and tries to output its string of data on to the stdout, but here is the catch. Since 
Task2 is blocked for random number 
of ticks, we don't know when it will wake up. If it wakes up, then it will definitely preempt the Task1 which may be in the middle of printing 
string. so you will see a distorted output, if you don't use mutex to protect the stdout.


Ways to protect the Critical Section:
1. Binary Semaphore
2. Mutex
3. Crude Way (disabling interrupts of the system, either globally, or up to a specific interrupt priority level)
	-taskENTER_CRITICAL(), taskEXIT_CRITICAL()

Question 1:
Is it true that binary semaphore is similar to mutex ?
Yes both are exactly same, but mutex can minimize the effect of priority inversion by using priority inheritance technique.

Question 2:
Is it true that binary semaphore can be used for synchronization between interrupt and task ?
Yes.

Question 3:
Is it possible to use binary semaphore to synchronize between multiple fast triggering interrupts and task ?
No. In this case counting semaphore is well suited as discussed in the course, because it can latch more events.

Question 4:
Is it true that binary semaphore while protecting the critical section will disable the interrupt ?
No. Neither mutex or semaphore disables the interrupt

Question 5:
Let's say in a RTOS application, person 'A' implements Task A and person 'B' implements Task B, and there is a shared resource, 
now what is the best strategy to protect the access to the shared resource ?
Disable interrupt before accessing the shared resource and enable it after completion.
Yes! Person 'A' doesn't know what Person 'B' Does, so best strategy is disable/enable interrupt

Question 6:
If Task-1 takes the semaphore, then any random Task of that application can 'give' it ?
Yes. As long as the semaphore handle is accessible(global), any one can 'give' or 'take' using that handle.

Question 7:
Lets say Task-1 locks the critical section by taking the semaphore , do you think a random Task-2 can able to access that critical section without 
taking the semaphore?
Yes. Yes of course, no one can stop Task-2 to access that critical section, if Task-1 is worried about this it has to disable the interrupt before 
accessing the critical section.
