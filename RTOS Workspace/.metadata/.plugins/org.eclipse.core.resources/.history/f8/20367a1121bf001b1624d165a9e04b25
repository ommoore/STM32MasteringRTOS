/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/* Library includes */
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

/* FreeRTOS includes */
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "queue.h"

#include "stm32f4xx.h"

#define DWT_CTRL    (*(volatile uint32_t*)0xE0001000)

//Global Variables
char usr_msg[250] = {0};

TaskHandle_t xTaskHandleM = NULL;
TaskHandle_t xTaskHandleE = NULL;

//function prototypes
static void prvSetupHardware(void);
void printmsg(char *msg);
static void prvSetupUart(void);
void prvSetupGpio(void);

static void vManagerTask(void *pvParameters);
static void vEmployeeTask(void *pvParameters);

extern void SEGGER_UART_init(uint32_t);

/* Semaphore Handle is used to reference the semaphore that is used to synchronize both manager and employee tasks */
xSemaphoreHandle xWork;
/* The Queue which the manager uses to put the work ticket id */
xQueueHandle xWorkQueue;

int main(void) {

	SEGGER_UART_init(500000);
	// Used to collect SEGGER Event time-stamps
	DWT->CTRL |= (1 << 0); //Enable CYCCNT in DWT_CTRL

	//1. Reset the RCC clock config to the default reset state.
	//HSI ON, PLL OFF, HSE OFF, system clock = 16MHz, cpu_clock = 16MHz
	RCC_DeInit();

	//2. Update the SystemCoreClock variable
	SystemCoreClockUpdate();

	prvSetupHardware();

	//Start Recording with Segger SystemView
	SEGGER_SYSVIEW_Conf();
	//SEGGER_SYSVIEW_Start();

	sprintf(usr_msg, "Demo of Counting Semaphore usage\r\n");
	printmsg(usr_msg);

	/* Dynamic memory allocation of Semaphore and Queue */
	//Create binary semaphore explicitly before use with max count value of 10, and initial count of 0
	xCountingSemaphore = vSemaphoreCreateCounting(10, 0);

	//Check for successful creation of counting semaphore
	if(xCountingSemaphore != NULL) {
		//Enable the button interrupt and set its priority
		prvSetupSoftwareInterrupt();

		vTaskStartScheduler();
	}

	sprintf(usr_msg, "Counting Semaphore creation failed... \r\n");
	printmsg(usr_msg);

	//Code will never reach here if creation of Queue/Semaphore was successful because the scheduler will be running the tasks indefinitely.
	//If it does reach here, then it is likely due to insufficient heap memory available for a resource to be created.

	for(;;); /* Loop forever */
}


static void prvSetupHardware(void) {
	//Setup Button and LED
	prvSetupGpio();

	//Setup UART1
	prvSetupUart();
}

void printmsg(char *msg) {
	for(uint32_t i = 0; i < strlen(msg); i++) {
		while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) != SET);
		USART_SendData(USART1, msg[i]);
	}
	while(USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET);
}

static void prvSetupUart(void) {
	GPIO_InitTypeDef gpio_uart_pins;
	USART_InitTypeDef usart1_init;

	//1. Enable the USART1 and GPIOA Peripheral clock
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	//PA9 is USART1_TX, PA10 is USART1_RX

	//2. Alternate function configuration of MCU pins to behave as USART1 TX and RX
	//zeroing each and every member element of the structure
	memset(&gpio_uart_pins, 0, sizeof(gpio_uart_pins));

	gpio_uart_pins.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;
	gpio_uart_pins.GPIO_Mode = GPIO_Mode_AF;
	gpio_uart_pins.GPIO_PuPd = GPIO_PuPd_UP;
	gpio_uart_pins.GPIO_OType= GPIO_OType_PP;
	gpio_uart_pins.GPIO_Speed = GPIO_High_Speed;
	GPIO_Init(GPIOA, &gpio_uart_pins);

	//3. AF mode settings for the pins
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1); //PA9
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1); //PA10

	//4. USART parameter initializations
	//zeroing each and every member element of the structure
	memset(&usart1_init, 0, sizeof(usart1_init));

	usart1_init.USART_BaudRate = 115200;
	usart1_init.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	usart1_init.USART_Mode =  USART_Mode_Tx | USART_Mode_Rx;
	usart1_init.USART_Parity = USART_Parity_No;
	usart1_init.USART_StopBits = USART_StopBits_1;
	usart1_init.USART_WordLength = USART_WordLength_8b;
	USART_Init(USART1, &usart1_init);

	//5. Enable the USART1 peripheral
	USART_Cmd(USART1, ENABLE);
}

void prvSetupGpio(void) {
	//Board specific initializations

	//Peripheral clock enable for GPIOB and GPIOC
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

	GPIO_InitTypeDef ledred_init, button_init;
	ledred_init.GPIO_Mode = GPIO_Mode_OUT;
	ledred_init.GPIO_OType = GPIO_OType_PP;
	ledred_init.GPIO_Pin = GPIO_Pin_7;
	ledred_init.GPIO_Speed = GPIO_Low_Speed;
	ledred_init.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &ledred_init);

	button_init.GPIO_Mode = GPIO_Mode_IN;
	button_init.GPIO_OType = GPIO_OType_PP;
	button_init.GPIO_Pin = GPIO_Pin_13;
	button_init.GPIO_Speed = GPIO_Low_Speed;
	button_init.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &button_init);
}
