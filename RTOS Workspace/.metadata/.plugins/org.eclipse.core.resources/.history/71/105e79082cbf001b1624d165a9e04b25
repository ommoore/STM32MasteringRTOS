/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/* Library includes */
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

/* FreeRTOS includes */
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

#include "stm32f4xx.h"

#define DWT_CTRL    (*(volatile uint32_t*)0xE0001000)

//Global Variables
char usr_msg[250] = {0};

TaskHandle_t xTaskHandle1 = NULL;
TaskHandle_t xTaskHandle2 = NULL;

//function prototypes
static void prvSetupHardware(void);
void printmsg(char *msg);
static void prvSetupUart(void);
void prvSetupGpio(void);

//Tasks to be created
static void vHandlerTask(void *pvParameters);
static void vPeriodicTask(void *pvParameters);

//Enable the software interrupt and set its priority
static void prvSetupSoftwareInterrupt(void);

//The service routine for the interrupt. This is the interrupt that the task will be synchronized with.
void vSoftwareInterruptHandler(void);

extern void SEGGER_UART_init(uint32_t);

/* Semaphore Handle is used to reference the semaphore that is used to synchronize both manager and employee tasks */
xSemaphoreHandle xCountingSemaphore;

int main(void) {

	SEGGER_UART_init(500000);
	// Used to collect SEGGER Event time-stamps
	DWT->CTRL |= (1 << 0); //Enable CYCCNT in DWT_CTRL

	//1. Reset the RCC clock config to the default reset state.
	//HSI ON, PLL OFF, HSE OFF, system clock = 16MHz, cpu_clock = 16MHz
	RCC_DeInit();

	//2. Update the SystemCoreClock variable
	SystemCoreClockUpdate();

	prvSetupHardware();

	//Start Recording with Segger SystemView
	SEGGER_SYSVIEW_Conf();
	//SEGGER_SYSVIEW_Start();

	sprintf(usr_msg, "Demo of Counting Semaphore usage\r\n");
	printmsg(usr_msg);

	/* Dynamic memory allocation of Semaphore */
	//Create binary semaphore explicitly before use with max count value of 10, and initial count of 0
	xCountingSemaphore = xSemaphoreCreateCounting(10, 0);

	//Check for successful creation of counting semaphore
	if(xCountingSemaphore != NULL) {
		//Enable the button interrupt and set its priority
		prvSetupSoftwareInterrupt();

		/* Create the 'handler' task. This task will be sync'd with the interrupt. The handler task is created
		 * with a high priority to ensure it runs immediately after the interrupt exits. In this case, a prio of 3 is chosen.*/
		xTaskCreate(vHandlerTask, "Handler", 500, NULL, 1, NULL);

		/* Create the task that will periodically generate a software interrupt. This is created with a priority below
		 * the handler task to ensure it will get preempted each time the handler task exists in the Blocked State*/
		xTaskCreate(vPeriodicTask, "Periodic", 500, NULL, 3, NULL);

		/* Start the scheduler so the created tasks start executing */
		vTaskStartScheduler();
	}

	sprintf(usr_msg, "Counting Semaphore creation failed... \r\n");
	printmsg(usr_msg);

	//Code will never reach here if creation of Queue/Semaphore was successful because the scheduler will be running the tasks indefinitely.
	//If it does reach here, then it is likely due to insufficient heap memory available for a resource to be created.

	for(;;); /* Loop forever */
}

static void vHandlerTask(void *pvParameters) {

	for(;;) {
		/* Use the semaphore to wait for the event. The semaphore was created before the scheduler started, in other words
		 * before this task ran for the first time. The task blocks indefinitely meaning this function call will only return once
		 * the semaphore has been successfully obtained - so there is no need to check the returned value. */
		xSemaphoreTake(xCountingSemaphore, portMAX_DELAY);

		/* To get here, the event must have occurred. Process the event (in this case just print the message) */
		sprintf(usr_msg, "Handler task - processing event.\r\n");
		printmsg(usr_msg);
	}
}

static void vPeriodicTask(void *pvParameters) {

	for(;;) {
		/* This task is used to simulate an interrupt by periodically generating a software interrupt. */
		vTaskDelay(pdMS_TO_TICKS(500));

		/* Generate the interrupt, printing a message before and after so the sequence of execution is evident */
		sprintf(usr_msg, "Periodic task - Pending the interrupt.\r\n");
		printmsg(usr_msg);

		//pend the interrupt
		NVIC_SetPendingIRQ(EXTI15_10_IRQn);

		sprintf(usr_msg, "Periodic task - Resuming.\r\n");
		printmsg(usr_msg);
	}
}

static void prvSetupSoftwareInterrupt() {
	/* Here we are simulating the button interrupt by manually setting the interrupt enable bit in the NVIC enable register */

	/* The interrupt service routine uses an interrupt-safe FreeRTOS API function so the interrupt priority must be at or below
	 * the priority defined by configSYSCALL_INTERRUPT_PRIORITY */

	NVIC_SetPriority(EXTI15_10_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);

	/* Enable the interrupt */
	NVIC_EnableIRQ(EXTI15_10_IRQn);
}

void EXTI15_10_IRQHandler(void) {
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	/* 'Give' the semaphore multiple times. The first will unblock the handler task, the following 'gives' are to demonstrate that
	 * the semaphore latches the events to allow the handler task to process them in turn without any events getting lost. This
	 * simulates multiple interrupts being taken by the processor, even though in this case the events are simulated within a single
	 * interrupt occurence */
	sprintf(usr_msg, "==>Button_Handler\r\n");
	printmsg(usr_msg);

	xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);
	xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);
	xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);
	xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);
	xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);

	/* Clear the software interrupt bit using the interrupt controllers */

	/* Giving the semaphore may have unblocked a task - if it did and the unblocked task has a priority equal or greater than the
	 * currently executing task, then xHigherPriorityTaskWoken will have been set to pdTRUE and portEND_SWITCHING_ISR() will force
	 * a context switch to the newly unblocked higher priority task.
	 *
	 * Note: The syntax for forcing a context switch within an ISR varies between FreeRTOS ports. The portEND_SWITCHING_ISR() macro is
	 * provided as part of the Cortex M3 port layer for this purpose. taskYIELD() must never be called from an ISR! */

	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
}

static void prvSetupHardware(void) {
	//Setup Button and LED
	prvSetupGpio();

	//Setup UART1
	prvSetupUart();
}

void printmsg(char *msg) {
	for(uint32_t i = 0; i < strlen(msg); i++) {
		while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) != SET);
		USART_SendData(USART1, msg[i]);
	}
	while(USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET);
}

static void prvSetupUart(void) {
	GPIO_InitTypeDef gpio_uart_pins;
	USART_InitTypeDef usart1_init;

	//1. Enable the USART1 and GPIOA Peripheral clock
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	//PA9 is USART1_TX, PA10 is USART1_RX

	//2. Alternate function configuration of MCU pins to behave as USART1 TX and RX
	//zeroing each and every member element of the structure
	memset(&gpio_uart_pins, 0, sizeof(gpio_uart_pins));

	gpio_uart_pins.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;
	gpio_uart_pins.GPIO_Mode = GPIO_Mode_AF;
	gpio_uart_pins.GPIO_PuPd = GPIO_PuPd_UP;
	gpio_uart_pins.GPIO_OType= GPIO_OType_PP;
	gpio_uart_pins.GPIO_Speed = GPIO_High_Speed;
	GPIO_Init(GPIOA, &gpio_uart_pins);

	//3. AF mode settings for the pins
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1); //PA9
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1); //PA10

	//4. USART parameter initializations
	//zeroing each and every member element of the structure
	memset(&usart1_init, 0, sizeof(usart1_init));

	usart1_init.USART_BaudRate = 115200;
	usart1_init.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	usart1_init.USART_Mode =  USART_Mode_Tx | USART_Mode_Rx;
	usart1_init.USART_Parity = USART_Parity_No;
	usart1_init.USART_StopBits = USART_StopBits_1;
	usart1_init.USART_WordLength = USART_WordLength_8b;
	USART_Init(USART1, &usart1_init);

	//5. Enable the USART1 peripheral
	USART_Cmd(USART1, ENABLE);
}

void prvSetupGpio(void) {
	//Board specific initializations

	//Peripheral clock enable for GPIOB and GPIOC
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

	GPIO_InitTypeDef ledred_init, button_init;
	ledred_init.GPIO_Mode = GPIO_Mode_OUT;
	ledred_init.GPIO_OType = GPIO_OType_PP;
	ledred_init.GPIO_Pin = GPIO_Pin_7;
	ledred_init.GPIO_Speed = GPIO_Low_Speed;
	ledred_init.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &ledred_init);

	button_init.GPIO_Mode = GPIO_Mode_IN;
	button_init.GPIO_OType = GPIO_OType_PP;
	button_init.GPIO_Pin = GPIO_Pin_13;
	button_init.GPIO_Speed = GPIO_Low_Speed;
	button_init.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &button_init);
}
